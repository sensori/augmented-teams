---
description: Domain-Driven Design analysis principles for extracting domain structures and interaction flows
globs: ["**/*.md", "**/*.txt", "**/*.mdc", "**/*.js", "**/*.ts", "**/*.py", "**/*.mjs", "**/*-domain-map.*", "**/*-domain-interactions.*"]
alwaysApply: false
---
**When** analyzing code, text, or diagrams to extract domain models and interaction flows,
**then** follow these principles to create clear, business logic-centered domain representations.

Domain-Driven Design analysis identifies core business concepts, their relationships, organizing principles, and how they interact to fulfill business scenarios. The goal is to map from the user's mental model and maintain domain-level abstraction throughout.

**Executing Commands:**
* `/ddd-structure` — Analyze code/text/diagrams to extract domain structure
* `/ddd-interaction` — Document domain concept interactions and business flows

## Conventions

Naming conventions, file locations, and structural conventions for DDD analysis outputs.

* **Domain map naming**: Use `<system-name>-domain-map.txt` for domain structure outputs
* **Domain interactions naming**: Use `<system-name>-domain-interactions.txt` for interaction flow outputs
* **File location**: Place domain maps and interactions in same directory as source code
* **Output format**: Text-based hierarchical structure with tabs for nesting levels
* **Domain concepts**: Named as nouns (things that exist)
* **Behaviors**: Described as verbs (what concepts do)
* **Relationships**: Embedded within each concept (not separate sections)

## 1. Use Outcome Verbs, Not Communication Verbs

Each verb should describe the actual outcome or artifact being created, not the act of communicating/presenting information. If you can ask 'showing WHAT?' or 'displaying WHAT?', the verb is too generic—use what comes after instead.

**[DO]:**
* Use verbs that describe artifacts/outcomes: "Animation", "Feedback", "Indicators", "Configuration"
* Name concepts by what they ARE or CREATE: "Power Activation Animation", "Combat Outcome Feedback"
* Focus on tangible results: "Hit Indicators", "Save Result Feedback"
* Use domain-specific action verbs: "animates", "triggers", "composes", "orchestrates"

**[DON'T]:**
* Use generic communication verbs: "showing", "displaying", "visualizing", "presenting"
* Use vague enablement verbs: "providing", "enabling", "allowing"
* Name concepts by their mechanism: "Visualizing Power Activation", "Showing Combat Results"
* Focus on presentation: "Display System", "Show Component"

## 2. Integrate System Support Into Domain Concepts

When you see 'SYSTEM SUPPORT FOR X' or other system type sections that contain lots of references to other domain sections, ask: does this implement the exact same functional capability as section X, just showing technical details? If yes, nest and integrate the system support UNDER the domain concept it implements, not as a separate section. Only keep system support separate if it enables multiple different domain capabilities or represents a genuinely different concern from the user's perspective.

**[DO]:**
* Nest technical implementation under the domain concept it serves
* Integrate "how" under "what" when they serve the same functional goal
* Keep implementation details close to the feature they implement
* Group by functional capability, not code organization

**[DON'T]:**
* Separate domain concepts from their implementations into parallel sections
* Create "SYSTEM SUPPORT" sections that duplicate domain structure
* Organize by code boundaries (services, models, controllers)
* Split concepts users see as one thing into multiple sections

## 3. Order by User Mental Model, Not Code Structure

Order concepts by user's mental model: what do they encounter first and what builds on what? If something labeled 'Technical Implementation' contains the core objects users interact with, ensure it's a primary domain concept that other features build upon. Ask: would a user need to understand this concept BEFORE understanding the features that use it?

**[DO]:**
* Order concepts by user encounter sequence
* Put foundational objects BEFORE features that use them
* Start with core domain objects (PowerItem, User, Vehicle)
* Follow with operations on those objects
* End with supporting infrastructure
* Ask: "What builds on what?" from user perspective

**[DON'T]:**
* Order by code structure (models, services, controllers)
* Hide core objects in "Technical Implementation" sections
* Start with features before introducing the objects they operate on
* Follow code dependency graphs instead of user understanding flow

## 4. Organize by Domain First, System Support Second

Organize by what the user understands (domain concepts) not by how the code is structured (system layers). Favor domain-specific concepts over system-level concepts. In a vehicle domain: cars, passengers, bikes, acceleration, direction come BEFORE events, rendering, or validating.

**[DO]:**
* Lead with domain-specific concepts (Powers, Combat, Vehicles, Users)
* Name sections by business capabilities: "Power Activation", "Payment Processing"
* Group related domain concepts together
* Put system infrastructure at the end
* Frame purpose from functional perspective: "Make powers feel distinct"

**[DON'T]:**
* Lead with system concepts (Events, UI, Services, Data Layer)
* Name sections by technical layers: "Presentation Layer", "Business Logic"
* Mix domain and system concepts at same level
* Frame purpose from technical perspective: "Render visual effects"

## 5. Refine Scope to Functional Accomplishment

Refine scope of the domain to what is actually being accomplished from a functional perspective. If examining a module about vehicles that interacts with a map to display position and facing of cars, frame the domain as "updating cars so they can be rendered on the map", or inversely "display position of cars every time their position and rotation change".

**[DO]:**
* Focus on functional outcomes, not mechanisms
* Frame domains by what they accomplish for users
* Ask: "What does this enable the user to do or understand?"
* State the transformation or capability provided
* Be specific about the functional benefit

**[DON'T]:**
* Frame domains by their technical implementation
* Focus on "how" before "what"
* Use generic system capabilities as domain names
* Describe mechanisms instead of outcomes

## 6. Maximize Integration of Related Concepts

Related concepts that serve the same functional goal should be maximally integrated, not artificially separated by code boundaries. If two concepts always work together from the user's perspective, they should be presented together.

**[DO]:**
* Group concepts that the user sees as one capability
* Nest implementation details under the feature they serve
* Keep related data and operations together
* Eliminate artificial boundaries based on code organization

**[DON'T]:**
* Separate related concepts into different major sections
* Split based on code layers (data, business, presentation)
* Duplicate related concepts across multiple sections
* Create gaps that break the user's mental model

## 7. Domain Concepts Are Nouns, Behaviors Are Verbs

Domain concepts should be named as nouns (things that exist), and their operations should be described as behaviors (verbs). If a verb feels important enough to be its own concept, it must have state and logic of its own - then it becomes a noun (e.g., "Animation" not "Animating", "Resolution" not "Resolving").

**[DO]:**
* Name domain concepts as nouns: "Animation", "Power Item", "Sequence", "Configuration"
* Describe what the concept IS first, then what it DOES
* Use verbs to describe behaviors on concepts: "Resolves animation", "Executes when triggered"
* If a verb has its own state/logic, make it a noun concept
* Mark behaviors with "(behavior)" suffix for clarity

**[DON'T]:**
* Name domain concepts as verbs or gerunds: "Animation Resolution", "Animation Execution"
* Use "-ing" forms for concept names: "Animating", "Resolving", "Processing"
* Create separate concepts for "Doing X" vs "X" - combine them
* Hide the noun form - always lead with what the thing IS

## 8. Assign Behaviors to the Concept That Performs Them

Always assign behaviors to the domain concept that actually performs them, not to the result or output. Ask "Who does this?" or "What class/object contains this logic?" to determine correct placement. The behavior belongs to the actor, not the artifact created.

**[DO]:**
* Place behavior under the concept that contains the logic
* Ask "Whose responsibility is this?" when placing behaviors
* Look at the code - which class has the method?
* Put creation logic with the creator, not the created
* Assign resolution logic to the resolver, not the resolved

**[DON'T]:**
* Place behavior under the result/output concept
* Assign behavior based on what it produces
* Put logic under the artifact it creates
* Organize by data flow instead of responsibility

## 9. Avoid Noun Redundancy in Domain and Concept Names

When multiple domains or concepts share the same root noun, they create ambiguity and suggest poor separation of concerns. PREFER INTEGRATION - nest related concepts under one domain. Only use distinct nouns when domains truly serve different purposes that cannot be integrated.

**[DO]:**
* INTEGRATE first: nest related concepts under parent domain (90% of cases)
* Only rename if truly distinct: use distinct nouns ONLY when integration doesn't make sense (10% of cases)
* Test for uniqueness: can you remove the qualifier and still know what it is?
* Use subject-area nouns when domains are genuinely separate

**[DON'T]:**
* Rename without considering integration - this is a cop-out that hides the real issue
* Repeat same noun with different prefixes: "X Animation", "Y Animation", "Z Animation"
* Use vague qualifiers to avoid integration: "Animation 1", "Animation System", "Animation Module"
* Create parallel domains that should be nested
* Allow concept name collisions at same hierarchy level

## 10. Organization: Domain Concepts Over File Structure

Organize around domain concepts (what things ARE and what you DO with them), not file structure, code organization, or technical artifacts. If you find yourself organizing by file types (.mdc, .md, .py) or technical layers (data, logic, presentation), stop and reorganize around user-facing capabilities.

**[DO]:**
* Organize by domain concepts with nested capabilities
* Ask: "What is this domain about?" not "What files does it have?"
* Group by functional capability
* Name sections by what they accomplish
* Integrate infrastructure under primary domain if single use

**[DON'T]:**
* Organize by file types: "Rule Files", "Command Files", "Runner Files"
* Organize by technical structure: "Configuration Layer", "Execution Layer"
* Split capabilities across multiple sections
* Name sections by artifacts: "Documentation", "Scripts", "Configs"
* Keep infrastructure separate if it only serves one domain

## 11. Domain Interaction Analysis: Maintain Abstraction Level

When documenting how domain concepts interact to fulfill business scenarios, maintain the same abstraction level as the domain map. Speak at domain concept level, describing business transformations, business lookups, and business rules - never include technical implementation details.

**[DO]:**
* Refer to domain concepts by name from domain map
* Describe business transformations (PowerItem to Animation configuration)
* Describe business lookups and validations (finds macro by priority, matches power by type)
* Describe business rules (teleport cancels drag, attached takes precedence)
* Mention platform/external APIs at high level only (Foundry triggers hook, Sequencer plays animation)
* Focus on what business concept does and why
* Structure scenarios: Trigger to Actors to Flow to Business Rules to Result
* Use arrow notation for transformations (A to B)
* State priorities as ordered lists
* Explain special cases as business rules

**[DON'T]:**
* Include field names, property paths, or data structure details
* Show HTML queries, DOM manipulation, or UI framework calls
* Display code syntax, variable names, or function signatures
* List CSS properties, styling details, or visual implementation
* Show API parameters, configuration objects, or technical schemas
* Focus on how code implements the concept
* Show if/else code structure or boolean logic operators
* List edge case handling code
* Show constructor calls or object creation code
* Include search algorithms or iteration code

## Commands

Commands that implement or use this rule:

* `/ddd-structure` — Analyze code/text/diagrams to extract domain structure
* `/ddd-structure-generate` — Generate domain structure (delegates to `/ddd-structure` generate action)
* `/ddd-structure-validate` — Validate domain structure (delegates to `/ddd-structure` validate action)
* `/ddd-interaction` — Document domain concept interactions and business flows
* `/ddd-interaction-generate` — Generate interaction flows (delegates to `/ddd-interaction` generate action)
* `/ddd-interaction-validate` — Validate interaction flows (delegates to `/ddd-interaction` validate action)
