---
description: Domain-Driven Design detailed object model extraction from domain documents
globs: ["**/*-domain-scaffold.txt", "**/*-domain-map.txt", "**/*-domain-interactions.txt", "**/*.md", "**/*.txt"]
alwaysApply: false
---
**When** extracting detailed object models from domain documents (scaffolds, maps, interactions),
**then** follow these principles to create clear, relationship-focused domain representations.

Detailed model extraction identifies first-order concepts, their properties, relationships, and inheritance hierarchies. The goal is to create a navigable object model using natural language from the source.

**Executing Commands:**
* `\ddd-detailed-model` — Extract detailed object model from domain document
* `\ddd-detailed-model-validate` — Validate model against DDD principles

---

## OVERVIEW: Detailed Object Model Format

**Purpose:**
Extract detailed object models from domain documents and represent them with:
1. ASCII class diagram showing visual overview
2. Concept definitions with fields and relationships
3. Relationship summary documenting connections

**Output Format:**
Text-based object model with ASCII diagrams and concept definitions.

**Key Elements:**
1. **ASCII Class Diagram** - Visual overview of major concepts and relationships
2. **Concept Definitions** - Each first-order concept with fields and relationships
3. **Inheritance Notation** - `: ParentClass` for specialization
4. **Natural Language Relationships** - Using exact phrasing from source
5. **Relationship Summary** - Categorized list of all connections

**Example Structure:**
```
// ASCII CLASS DIAGRAM
/*
    ┌──────────┐
    │ Content  │
    ├──────────┤
    │ filePath │
    └────┬─────┘
         │ 1:1
         ▼
    ┌──────────┐
    │ Command  │
    └──────────┘
*/

Content {
  filePath: string
  fileExtension: string
  
  - is being processed by --> Command (1:1)
}

Command {
  commandName: string
  status: CommandStatus (ex: PENDING, IN_PROGRESS)
  
  - processes --> Content (1:1)
}

CodeGuidingCommand : Command {
  validationMode: ValidationMode (ex: STRICT, LENIENT)
  
  - performs code augmented AI guidance
}
```

**Validation Checklist:**
- [ ] ASCII diagram shows major concepts and relationships
- [ ] All first-order concepts identified from source
- [ ] Relationships use natural language from source document
- [ ] Inheritance hierarchies properly identified
- [ ] No implementation details (IDs, unnecessary headers)
- [ ] No upward references (base doesn't know subclasses)
- [ ] Unidirectional relationships where appropriate

---

## § 1: Identify First-Order Concepts

**Principle:**
Extract all nouns from the source document that represent independent concepts with their own identity, lifecycle, or behavioral responsibilities. These become the building blocks of your object model.

**Do:**
* Extract major nouns as concepts: "Content", "Command", "Rule", "Principle"
* From scaffolds: Look for "describe" subjects and nested concepts
* From maps: Domain concepts become primary entities
* From interactions: Actors and artifacts become concepts
* Include both concrete and abstract concepts

**Don't:**
* Skip concepts that seem "small" or "simple"
* Combine concepts that have different responsibilities
* Create concepts for implementation details (repositories, services)
* Miss concepts mentioned only in relationships

**Examples:**

✅ **DO - Extract All First-Order Concepts:**
```
Source: "describe a piece of content that is being processed by a command"
Concepts Identified:
- Content
- Command

Source: "that implements a specializing rule"
Additional Concept:
- SpecializingRule

Source: "it should select the appropriate specialized rule based on file extension"
Additional Concept:
- SpecializedRule

Source: "it should include base rule principles"
Additional Concepts:
- BaseRule
- Principle
```

❌ **DON'T - Miss Implied Concepts:**
```
Source: "it should analyze content for violations using the heuristic"
Wrong: Only extract "Content" and "Violation"
Missing: CodeHeuristic (mentioned as "the heuristic")

Why wrong: Every noun that represents a distinct thing should be extracted
```

❌ **DON'T - Create Implementation Concepts:**
```
Wrong Extraction:
- ContentRepository
- CommandFactory
- RuleService

Why wrong: These are implementation patterns, not domain concepts from the source
Source mentions: Content, Command, Rule (use these instead)
```

---

## § 2: Map Relationships Using Natural Language

**Principle:**
Use the exact phrasing from the source document to describe relationships. Don't translate to technical terms—preserve the user's language to maintain domain clarity and traceability.

**Do:**
* Use exact phrases: "is being processed by", "provides principled guidance through"
* Keep conditional language: "may be verified", "can implement"
* Preserve cardinalities from context: (1:1), (1:*), (0:1)
* Use arrows to show direction: `-->`
* Quote the source when relationship is clear

**Don't:**
* Translate to generic terms: "has", "uses", "contains" (unless source says this)
* Add technical jargon: "aggregates", "composes", "injects"
* Change verb tense or voice from source
* Simplify rich domain language to programmer-speak

**Examples:**

✅ **DO - Preserve Natural Language:**
```
Source: "content that is being processed by a command"
Relationship:
Content {
  - is being processed by --> Command (1:1)
}

Source: "provides principled guidance through principles"
Relationship:
BaseRule {
  - provides principled guidance through --> Principle[] (1:*)
}

Source: "may be verified for consistency against specializing rule"
Relationship:
SpecializedRule {
  - may be verified for consistency against --> SpecializingRule (0:1)
}
```

❌ **DON'T - Use Generic Technical Terms:**
```
Source: "is being processed by a command"
Wrong:
Content {
  - has --> Command (1:1)
  - uses --> Command (1:1)
}

Why wrong: Loses the semantic meaning of "processing"
Correct: "is being processed by" tells a story
```

❌ **DON'T - Add Technical Jargon:**
```
Source: "provides principled guidance through principles"
Wrong:
BaseRule {
  - composes --> Principle[] (1:*)
  - aggregates --> Principle[] (1:*)
}

Why wrong: "Composes" and "aggregates" are technical patterns
Source says: "provides principled guidance through" (richer meaning)
```

---

## § 3: Identify Inheritance Hierarchies

**Principle:**
Look for specialization patterns in the source document where concepts extend or specialize other concepts. Use clear inheritance notation and group related types together.

**Do:**
* Look for patterns: "Command that implements...", "Rule that specializes..."
* Use `: ParentClass` notation after concept name
* Group parent and children near each other in output
* Identify abstract base concepts
* Note when specialization adds new fields or behaviors

**Don't:**
* Create deep inheritance hierarchies (>3 levels without good reason)
* Make base classes reference their subclasses
* Use inheritance for simple "has-a" relationships
* Force inheritance where composition is more natural

**Examples:**

✅ **DO - Clear Inheritance Notation:**
```
Source: "describe a test file that is being processed by a BDD command"
Then: "that implements a specializing rule for test frameworks"

Model:
Command {
  commandName: string
  status: CommandStatus (ex: PENDING, IN_PROGRESS)
  
  - processes --> Content (1:1)
}

CodeGuidingCommand : Command {
  validationMode: ValidationMode (ex: STRICT, LENIENT)
  
  - performs code augmented AI guidance
}

IncrementalCommand : Command {
  currentRunNumber: int
  sampleSize: int
  
  - implements incremental runs
}
```

✅ **DO - Multi-Level Hierarchy:**
```
Source: "specializing rule that selects appropriate specialized rule"

Model:
BaseRule {
  ruleName: string
  
  - provides principled guidance through --> Principle[] (1:*)
}

SpecializingRule : BaseRule {
  fileExtensionPattern: string
  
  - selects appropriate specialized rule based on --> file extension pattern
}

SpecializedRule : SpecializingRule {
  targetLanguage: string
  targetFramework: string
  
  - provides --> Example[] (1:*)
}
```

❌ **DON'T - Upward References:**
```
Wrong:
Command {
  - can implement incremental runs --> IncrementalCommand (1:1 mixin)
  - can be a phase in --> Workflow (0:1)
}

Why wrong: Base class shouldn't know about its subclasses
Correct: Remove these lines; inheritance is declared at subclass level
```

---

## § 4: Remove Implementation Details

**Principle:**
Focus on domain concepts and relationships, not implementation mechanics. Remove technical identifiers, unnecessary section headers, and implementation-specific details.

**Do:**
* Remove all ID fields: ruleId, commandId, violationId
* Use `ex:` instead of `enum:` for brevity
* Show relationship direction with arrows: `-->`
* Let concept blocks speak for themselves (no headers)
* Keep only domain-meaningful fields

**Don't:**
* Include ID fields (implementation detail)
* Use `// Fields` or `// Relationships` comment headers
* Add database columns or technical attributes
* Include timestamps unless domain-significant

**Examples:**

✅ **DO - Clean Concept Definition:**
```
Principle {
  principleNumber: int (e.g., 1, 2, 3, 4, 5)
  principleName: string
  description: string
  
  - belongs to --> BaseRule (1:1)
  - is illustrated by --> Example[] (1:*)
}

Example {
  exampleType: ExampleType (ex: DO, DONT)
  codeSnippet: string
  explanation: string
  
  - illustrates Dos and Donts for --> Principle (1:1)
}
```

❌ **DON'T - Include Implementation Details:**
```
Wrong:
Principle {
  // Fields
  principleId: string           ← Remove: implementation detail
  principleNumber: int
  principleName: string
  createdAt: timestamp          ← Remove: unless domain-significant
  updatedAt: timestamp          ← Remove: technical concern
  
  // Relationships                ← Remove: obvious from structure
  - belongs to --> BaseRule (1:1)
}
```

❌ **DON'T - Use Long Enum Syntax:**
```
Wrong:
status: CommandStatus (enum: PENDING, IN_PROGRESS, COMPLETE)

Correct:
status: CommandStatus (ex: PENDING, IN_PROGRESS, COMPLETE)
```

---

## § 5: Create ASCII Diagram

**Principle:**
Provide a visual overview using ASCII art that shows major concepts, their relationships, cardinalities, and inheritance hierarchies. Keep it clean and readable.

**Do:**
* Use box drawing characters: ┌─┐│└┘├┤┬┴
* Show major concepts as boxes
* Use arrows for relationships: →, ▼
* Include cardinalities: (1:1), (1:*), (0:1)
* Label relationships
* Show inheritance with clear notation
* Keep diagram focused on key relationships

**Don't:**
* Include every single concept (focus on architecture)
* Make diagram too complex to read
* Use inconsistent box sizes
* Forget to label relationships
* Miss inheritance connections

**Examples:**

✅ **DO - Clear Visual Overview:**
```
/*
                        ┌──────────────┐
                        │   Content    │ (Aggregate Root)
                        ├──────────────┤
                        │ filePath     │
                        │ fileExtension│
                        └──────┬───────┘
                               │ 1:1
                               │ processes
                               ▼
┌────────────┐           ┌──────────────┐
│  BaseRule  │           │   Command    │
├────────────┤           ├──────────────┤
│ ruleName   │           │ commandName  │
└─────┬──────┘           └──────┬───────┘
      │ 1:*                     │
      │ has                     │ inherits
      ▼                         │
┌────────────┐            ┌─────┴────────┐
│ Principle  │            │              │
└────────────┘            ▼              ▼
                    ┌──────────┐  ┌──────────┐
                    │   Code   │  │Increment-│
                    │  Guiding │  │   al     │
                    └──────────┘  └──────────┘

LEGEND:
  →  Association
  1:1  One-to-One
  1:*  One-to-Many
*/
```

❌ **DON'T - Overcomplicate:**
```
Wrong: Including every single concept and every relationship
Result: Diagram becomes unreadable, loses value

Correct: Show architecture-level view
Focus on: Major aggregates, key relationships, inheritance trees
```

---

## COMMON PATTERNS

### Pattern 1: Base → Specialized Hierarchy
```
Source mentions: "rule", "specializing rule", "specialized rule"

Model:
BaseRule {
  - provides principled guidance through --> Principle[] (1:*)
}

SpecializingRule : BaseRule {
  - is loaded and provides access to --> SpecializedRule[] (1:*)
}

SpecializedRule : SpecializingRule {
  - provides --> Example[] (1:*)
}
```

### Pattern 2: Behavioral Specialization
```
Source: "command that implements incremental runs"

Model:
Command {
  - processes --> Content (1:1)
}

IncrementalCommand : Command {
  sampleSize: int
  
  - implements incremental runs
  - provides sample size based on --> code analysis
}
```

### Pattern 3: Unidirectional Aggregation
```
Source: "violations are assembled into a report"

Model:
Violation {
  - violates --> Principle (1:1)
}

ViolationReport {
  - assembles related --> Violation[] (1:*)
}

Note: Violation doesn't know about ViolationReport (unidirectional)
```

---

## VALIDATION CHECKLIST

After extraction, validate your model:

**§ 1 Checklist - First-Order Concepts:**
- [ ] All major nouns from source extracted
- [ ] No implementation concepts added
- [ ] Abstract concepts identified
- [ ] Supporting concepts included

**§ 2 Checklist - Natural Language:**
- [ ] Exact phrasing from source used
- [ ] No generic "has"/"uses" unless in source
- [ ] Conditional language preserved
- [ ] Rich domain language maintained

**§ 3 Checklist - Inheritance:**
- [ ] Specialization patterns identified
- [ ] `: ParentClass` notation used
- [ ] No upward references
- [ ] Related types grouped together

**§ 4 Checklist - Clean Model:**
- [ ] All ID fields removed
- [ ] No section headers
- [ ] `ex:` used instead of `enum:`
- [ ] Only domain-meaningful fields

**§ 5 Checklist - ASCII Diagram:**
- [ ] Major concepts shown
- [ ] Relationships labeled
- [ ] Cardinalities included
- [ ] Inheritance visible
- [ ] Readable and focused

---

## COMMON ISSUES

| Issue | Solution |
|-------|----------|
| Too many concepts in diagram | Focus on architectural overview |
| Generic relationship names | Use exact phrasing from source |
| Base class knows subclasses | Remove upward references |
| ID fields everywhere | Remove all *Id fields |
| Deep hierarchies | Flatten or use composition |
| Bidirectional when should be uni | Check if both directions needed |
| Lost domain language | Go back to source, copy exact phrases |

**See Also:**
* `\ddd-analyze` — Extract domain structure first
* `\ddd-interactions` — Analyze domain interactions
* `\ddd-detailed-model-validate` — Validate model against principles
