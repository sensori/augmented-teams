---
description: Domain-Driven Design analysis principles for extracting domain structures and interaction flows
globs: ["**/*.md", "**/*.txt", "**/*.mdc", "**/*.js", "**/*.ts", "**/*.py", "**/*.mjs", "**/*-domain-map.*", "**/*-domain-interactions.*"]
alwaysApply: false
---
**When** analyzing code, text, or diagrams to extract domain models and document their interactions,
**then** follow these principles to create clear, business logic-centered domain representations that map from the user's mental model.

Domain-Driven Design analysis identifies core business concepts, their relationships, organizing principles, and interaction flows. The goal is to understand the business domain, not just the code structure.

**Executing Commands:**
* `/ddd-structure` — Analyze code/text/diagrams to extract domain structure
* `/ddd-interaction` — Document domain concept interactions and business flows

## Conventions

Naming conventions, file locations, and structural conventions for DDD analysis outputs:

* **Domain map naming**: `<system-name>-domain-map.txt` (e.g., `mm3e-animations-domain-map.txt`)
* **Domain interactions naming**: `<system-name>-domain-interactions.txt` (same folder as domain map)
* **Output format**: Text-based hierarchical structure with tab indentation for nesting
* **File location**: Place domain analysis outputs in same directory as source code being analyzed
* **Relationship notation**: Use `RELATIONSHIPS:` sections embedded in each concept, not separate
* **Domain ordering**: Domain concepts first, system infrastructure last

## 1. Use Outcome Verbs, Not Communication Verbs

Each verb should describe the actual outcome or artifact being created, not the act of communicating or presenting information. If you can ask 'showing WHAT?' or 'displaying WHAT?', the verb is too generic—use what comes after instead.

**[DO]:**
* Use verbs that describe artifacts or outcomes: "Animation", "Feedback", "Indicators", "Configuration"
* Name concepts by what they ARE or CREATE: "Power Activation Animation", "Combat Outcome Feedback"
* Focus on tangible results: "Hit Indicators", "Save Result Feedback"
* Use domain-specific action verbs: "animates", "triggers", "composes", "orchestrates"
* Test: Can you replace 'X-ing' with 'X' and still have a meaningful goal?

**[DON'T]:**
* Use generic communication verbs: "showing", "displaying", "visualizing", "presenting"
* Use vague enablement verbs: "providing", "enabling", "allowing"
* Name concepts by their mechanism: "Visualizing Power Activation", "Showing Combat Results"
* Focus on presentation: "Display System", "Show Component"

## 2. Integrate System Support Into Domain Concepts

When you see 'SYSTEM SUPPORT FOR X' or other system type sections containing references to domain sections, ask: does this implement the exact same functional capability as section X, just showing technical details? If yes, nest and integrate the system support UNDER the domain concept it implements, not as a separate section.

**[DO]:**
* Nest technical implementation under the domain concept it serves
* Integrate "how" under "what" when they serve the same functional goal
* Keep implementation details close to the feature they implement
* Group by functional capability, not code organization

**[DON'T]:**
* Separate domain concepts from their implementations into parallel sections
* Create "SYSTEM SUPPORT" sections that duplicate domain structure
* Organize by code boundaries (services, models, controllers)
* Split concepts users see as one thing into multiple sections

## 3. Order by User Mental Model, Not Code Structure

Order concepts by user's mental model: what do they encounter first and what builds on what? If something labeled 'Technical Implementation' contains core objects users interact with, ensure it's a primary domain concept that other features build upon.

**[DO]:**
* Order concepts by user encounter sequence
* Put foundational objects BEFORE features that use them
* Start with core domain objects (PowerItem, User, Vehicle)
* Follow with operations on those objects
* End with supporting infrastructure
* Ask: "What builds on what?" from user perspective

**[DON'T]:**
* Order by code structure (models, services, controllers)
* Hide core objects in "Technical Implementation" sections
* Start with features before introducing the objects they operate on
* Follow code dependency graphs instead of user understanding flow

## 4. Organize by Domain First, System Support Second

Organize by what the user understands (domain concepts) not by how the code is structured (system layers). Favor domain-specific concepts over system-level concepts. Domain capabilities come BEFORE system infrastructure.

**[DO]:**
* Lead with domain-specific concepts (Powers, Combat, Vehicles, Users)
* Name sections by business capabilities: "Power Activation", "Payment Processing"
* Group related domain concepts together
* Put system infrastructure at the end
* Frame purpose from functional perspective: "Make powers feel distinct"

**[DON'T]:**
* Lead with system concepts (Events, UI, Services, Data Layer)
* Name sections by technical layers: "Presentation Layer", "Business Logic"
* Mix domain and system concepts at same level
* Frame purpose from technical perspective: "Render visual effects"

## 5. Refine Scope to Functional Accomplishment

Refine scope of the domain to what is actually being accomplished from a functional perspective. Frame domains by what they enable users to do or understand, not by technical mechanisms.

**[DO]:**
* Focus on functional outcomes, not mechanisms
* Frame domains by what they accomplish for users
* Ask: "What does this enable the user to do or understand?"
* State the transformation or capability provided
* Be specific about the functional benefit

**[DON'T]:**
* Frame domains by their technical implementation
* Focus on "how" before "what"
* Use generic system capabilities as domain names
* Describe mechanisms instead of outcomes

## 6. Maximize Integration of Related Concepts

Related concepts that serve the same functional goal should be maximally integrated, not artificially separated by code boundaries. If two concepts always work together from the user's perspective, they should be presented together.

**[DO]:**
* Group concepts that the user sees as one capability
* Nest implementation details under the feature they serve
* Keep related data and operations together
* Eliminate artificial boundaries based on code organization

**[DON'T]:**
* Separate related concepts into different major sections
* Split based on code layers (data, business, presentation)
* Duplicate related concepts across multiple sections
* Create gaps that break the user's mental model

## 7. Domain Concepts Are Nouns, Behaviors Are Verbs

Domain concepts should be named as nouns (things that exist), and their operations should be described as behaviors (verbs). If a verb feels important enough to be its own concept, it must have state and logic of its own.

**[DO]:**
* Name domain concepts as nouns: "Animation", "Power Item", "Sequence", "Configuration"
* Describe what the concept IS first, then what it DOES
* Use verbs to describe behaviors on concepts: "Resolves animation", "Executes when triggered"
* If a verb has its own state and logic, make it a noun concept
* Test: Can you describe this concept without using a verb?

**[DON'T]:**
* Name domain concepts as verbs or gerunds: "Animation Resolution", "Animation Execution"
* Use "-ing" forms for concept names: "Animating", "Resolving", "Processing"
* Create separate concepts for "Doing X" vs "X" - combine them
* Hide the noun form - always lead with what the thing IS

## 8. Assign Behaviors to the Concept That Performs Them

Always assign behaviors to the domain concept that actually performs them, not to the result or output. Ask "Who does this?" or "What class/object contains this logic?" to determine correct placement.

**[DO]:**
* Place behavior under the concept that contains the logic
* Ask "Whose responsibility is this?" when placing behaviors
* Look at the code - which class has the method?
* Put creation logic with the creator, not the created
* Assign resolution logic to the resolver, not the resolved

**[DON'T]:**
* Place behavior under the result or output concept
* Assign behavior based on what it produces
* Put logic under the artifact it creates
* Organize by data flow instead of responsibility

## 9. Avoid Noun Redundancy in Domain and Concept Names

When multiple domains or concepts share the same root noun, they create ambiguity and suggest poor separation of concerns. PREFER INTEGRATION - nest related concepts under one domain. Only use distinct nouns when domains truly serve different purposes that cannot be integrated.

**[DO]:**
* INTEGRATE first: nest related concepts under one domain
* Only rename if truly distinct and integration doesn't make sense
* Test for uniqueness: can you remove the qualifier and still know what it is?
* Use subject-area nouns when domains are genuinely separate

**[DON'T]:**
* Rename without considering integration - this hides the real issue
* Repeat same noun with different prefixes: "X Animation", "Y Animation", "Z Animation"
* Use vague qualifiers to avoid integration: "Animation 1", "Animation System", "Animation Module"
* Create parallel domains that should be nested
* Allow concept name collisions at the same hierarchy level

## 10. Organization: Domain Concepts Over File Structure

Organize around domain concepts (what things ARE and what you DO with them), not file structure, code organization, or technical artifacts. If you find yourself organizing by file types or technical layers, stop and reorganize around user-facing capabilities.

**[DO]:**
* Organize by domain concepts with nested capabilities
* Ask: "What is this domain about?" not "What files does it have?"
* Group by functional capability
* Name sections by what they accomplish
* Integrate infrastructure under primary domain if only used once

**[DON'T]:**
* Organize by file types: "Rule Files", "Command Files", "Runner Files"
* Organize by technical structure: "Configuration Layer", "Execution Layer"
* Split capabilities across multiple sections
* Name sections by artifacts: "Documentation", "Scripts", "Configs"

## 11. Domain Interaction Analysis

When documenting how domain concepts interact to fulfill business scenarios, maintain the same abstraction level as the domain map, focusing on domain concept flows rather than implementation details.

### 11.1 Maintain Domain-Level Abstraction

Speak at the same abstraction level as the domain map. Only get specific when describing business transformations, lookups, or business rules. Never include technical implementation details.

**[DO]:**
* Refer to domain concepts by name from domain map
* Describe business transformations (PowerItem → Animation configuration)
* Describe business lookups and validations (finds macro by priority, matches power by type)
* Describe business rules (teleport cancels drag, attached takes precedence)
* Mention platform or external APIs at high level only
* Focus on what business concept does and why

**[DON'T]:**
* Include field names, property paths, or data structure details
* Show HTML queries, DOM manipulation, or UI framework calls
* Display code syntax, variable names, or function signatures
* List CSS properties, styling details, or visual implementation
* Show API parameters, configuration objects, or technical schemas

### 11.2 Structure Scenarios as Business Flows

Structure each scenario to show a complete business flow from trigger to result. Focus on domain concept participation and business logic, not code execution.

**Scenario Template:**
```
SCENARIO N: [BUSINESS SCENARIO NAME]

TRIGGER: [User action or system event]

ACTORS:
- [Domain Concept from map]
- [Domain Concept from map]

FLOW:
1. [Business step]
   [Domain concept action]
   [Business transformation/lookup]

2. [Next business step]
   [Domain concept interaction]

BUSINESS RULES:
- [Domain constraint]
- [Priority order]
- [Special cases]

RESULT: [Business outcome]
```

**[DO]:**
* Start with business event or trigger
* Show domain concept interactions
* Describe transformations (Object A → Object B)
* Describe lookups (finds by pattern, searches by type)
* State business rules inline
* End with business result

**[DON'T]:**
* Show code execution flow
* List function calls and parameters
* Include variable assignments
* Show error handling details
* Include logging or debugging steps

### 11.3 Describe Transformations at Domain Level

Describe business transformations showing what changes from one domain concept to another and why, using pattern: [Source Concept] → [Transformation Logic] → [Target Concept]

**[DO]:**
* State source and target concepts clearly
* Describe business purpose of transformation
* Mention key characteristics extracted or added
* Use arrow notation for clarity

**[DON'T]:**
* Show constructor calls or object creation code
* List every field being copied
* Include data type conversions
* Show object mapping logic

### 11.4 Describe Lookups as Business Logic

Describe business lookup logic showing search strategy and matching criteria without implementation details.

**[DO]:**
* Describe search strategy (priority order, pattern matching)
* State matching criteria as business rules
* Show fallback logic as business flow
* Use domain terminology

**[DON'T]:**
* Show database queries or API calls
* Include search algorithms or iteration code
* List filter functions or predicates
* Show null checking or error handling

### 11.5 State Business Rules Clearly

State business rules, priorities, and constraints clearly as domain logic, not code conditionals.

**[DO]:**
* State priorities as ordered lists
* Describe special cases as business rules
* Explain why rules exist (business rationale)
* Use domain terminology

**[DON'T]:**
* Show if/else code structure
* Include boolean logic operators
* List edge case handling code
* Show validation implementation

## Commands

Commands that implement or use this rule:

* `/ddd-structure` — Analyze code/text/diagrams to extract domain structure
* `/ddd-structure-generate` — Generate domain structure (delegates to `/ddd-structure` generate action)
* `/ddd-structure-validate` — Validate domain structure (delegates to `/ddd-structure` validate action)
* `/ddd-interaction` — Document domain concept interactions and business flows
* `/ddd-interaction-generate` — Generate interaction documentation (delegates to `/ddd-interaction` generate action)
* `/ddd-interaction-validate` — Validate interaction documentation (delegates to `/ddd-interaction` validate action)
