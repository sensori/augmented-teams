---
description: BDD testing practices for Jest/JavaScript
globs: ["**/*test*.js", "**/*test*.ts", "**/*test*.jsx", "**/*test*.tsx", "**/*spec*.js", "**/*spec*.ts", "**/*spec*.jsx", "**/*spec*.tsx"]
alwaysApply: false
---
**When** practicing BDD testing with Jest/JavaScript,
**then** follow these Jest-specific patterns.

This rule extends `bdd-rule.mdc` — all base BDD principles apply throughout.

**Executing Commands:**
* `/bdd-validate` — Validate BDD test files against these principles
* `/bdd-workflow` — Execute BDD workflow phases (Domain Scaffold, Signatures, Write Tests, Write Code)

## Conventions

Naming conventions, file locations, and structural conventions for Jest/JavaScript BDD tests (what the rules apply to, not the rule files themselves).

* Test file naming: Use `*test*.js`, `*test*.ts`, `*test*.jsx`, `*test*.tsx`, `*spec*.js`, `*spec*.ts`, `*spec*.jsx`, or `*spec*.tsx` patterns
* Test file location: Place test files alongside source code or in dedicated test directories following JavaScript/TypeScript/Jest conventions
* Framework syntax: Use Jest framework syntax: `describe()`, `it()`, `beforeEach()`, `expect()`
* Code examples: Use JavaScript/TypeScript syntax with Jest-specific patterns

## 1. Business Readable Language

Write `describe`/`it` so that inner/outer sentences create natural sentence. Use nouns for `describe` (concepts, states). Start each `it()` with "should …". Nest from broad → specific; each child adds context. Use plain behavioral language. Prefer domain terms over technical jargon.

**[DO]:**
* Use `describe()` for top-level concepts and nested contexts
* Use `it()` for individual behaviors
* Create natural sentences when reading describe → it
* Use nouns for describe blocks (concepts, states)
* Start each it() with "should" to describe expected behavior

```javascript
describe('a ranged damage power', () => {
  describe('that has targeted and resulted in a successful attack', () => {
    it('should apply damage based on degrees of failure', () => {
      expect(result.injuries).toBe(2);
    });
  });
});
```

**[DON'T]:**
* Use verbs for describe blocks
* Omit "should" from it() blocks
* Use technical jargon or class names
* Flatten hierarchy unnecessarily
* Use implementation-focused language

```javascript
describe('when Attack.targetToken()', () => {});
describe('retrieved attack', () => {});
it('sets isSubmitting flag', () => {});
```

## 2. Comprehensive and Brief

Test observable behavior, not hidden internals. Cover state, validation, rules, and interactions. Cover normal, edge, and failure paths. Keep tests short, expressive, readable. Keep tests independent, deterministic, and fast.

**[DO]:**
* Test observable outcomes and state changes
* Use `expect()` assertions for clear expectations
* Set up test data in `beforeEach()` blocks
* Write focused tests for each distinct behavior
* Keep test bodies concise and readable

```javascript
describe('a damage power', () => {
  beforeEach(() => {
    mockTarget = { dodge: 15, injury: 0 };
  });
  
  it('should be a ranged attack', () => {
    expect(attack.isRanged).toBe(true);
  });
  
  it('should calculate DC from targets dodge', () => {
    expect(attack.execute(mockTarget).DC).toBe(20);
  });
});
```

**[DON'T]:**
* Test internal methods or private attributes
* Assert on mock internals or framework internals
* Write overly broad tests
* Create tests that depend on execution order
* Access implementation details

```javascript
it('calls _validateCredentials()', () => {
  expect(form._internal_flag).toBe(true);
  expect(form._validateCredentials).toHaveBeenCalled();
});
```

## 3. Balance Context Sharing with Localization

Nest parent context, don't repeat it. Provide expected data via helper factories/builders. Extract complex logic into helpers. Reuse helpers/factories where possible. Move shared Arrange code to `beforeEach()` in parent context.

**[DO]:**
* Move shared setup to `beforeEach()` in parent describe blocks
* Use factory functions for creating test data
* Extract complex setup logic into reusable helpers
* Nest contexts to avoid repetition
* Balance shared context with test-specific setup

```javascript
const createPower = (o = {}) => ({ name: 'Test', rank: 10, ...o });

describe('a Power', () => {
  beforeEach(() => {
    power = createPower();
  });
});
```

**[DON'T]:**
* Duplicate setup code across sibling tests
* Repeat parent context setup unnecessarily
* Create overly complex setup in individual tests
* Mix shared and test-specific setup without clear separation
* Leave duplicate Arrange code in sibling tests

```javascript
describe('with an attached macro', () => {
  it('should return animation with type "attached"', () => {
    const mockMacro = { name: 'Custom', execute: jest.fn() };
    const mockItem = createMockItem({ getFlag: jest.fn().mockReturnValue('id') });
    const powerItem = new PowerItem(mockItem);
  });
  
  it('should provide macro name as animation name', () => {
    const mockMacro = { name: 'Custom', execute: jest.fn() };
    const mockItem = createMockItem({ getFlag: jest.fn().mockReturnValue('id') });
    const powerItem = new PowerItem(mockItem);  // Duplicate setup
  });
});
```

## 4. Cover All Layers of the System

Include separate front end, business logic, integration, and data access tests. Isolate across architecture boundaries with mocks and stubs.

**[DO]:**
* Write separate test files for each architectural layer
* Use `jest.mock()` to isolate layers
* Test business logic independently of data access
* Create integration tests for cross-layer behavior
* Use appropriate mocking strategies for each layer

**[DON'T]:**
* Mix concerns from different layers in the same test
* Test dependencies instead of the code under test
* Create tests that require multiple layers to be running
* Over-mock to the point where tests don't verify real behavior
* Skip testing important layers

## 5. Unit Tests the Front-End

Mock services, business logic, and routing. Stub user events and verify resulting state or view. Test user-visible behavior, not internal component state or methods.

**[DO]:**
* Mock backend services and business logic
* Test user-visible outcomes and interactions
* Verify component rendering and user interactions
* Focus on what users see and experience
* Use mocks to isolate front-end from backend

```javascript
describe('an attack power display', () => {
  beforeEach(() => {
    mockService = jest.fn();
    context = prepareContext(actor);
  });
  
  it('should include attack bonus in context', () => {
    expect(context.attackPowers[0].bonus).toBe(8);
  });
});
```

**[DON'T]:**
* Test internal component state or methods
* Assert on HTML rendering details or CSS
* Make real HTTP requests in unit tests
* Access component internals directly (e.g., `.state`, `.props`, `.instance()`)
* Test framework internals or implementation details

```javascript
it('renders bonus', () => {
  expect(html).toContain('value="8"');
  expect(html).toContain('color: blue');
  await fetch('http://api.com');
});
it('calls _onMount()', () => {
  expect(component._onMount).toHaveBeenCalled();
});
```

## 6. Signature Phase Requirements

When creating test signatures (Phase 1: Build Test Signatures), generate test structure with empty bodies:

**[DO]:**
* Use proper Jest syntax: `describe()`, `it()`, nested `describe()` blocks
* Keep test bodies empty (no statements)
* Mark each test with `// BDD: SIGNATURE` comment at start of body
* Preserve ALL nesting levels from scaffold hierarchy
* Convert plain English scaffold to proper code syntax
* Update test file directly (e.g., `zorbling.test.js`)
* Target ~18 describe blocks per signature iteration

```javascript
// From scaffold (plain English):
// Zorbling Management
//   Creating Zorblings
//     should create zorbling with valid data
//     should reject zorbling with invalid data

// To signature (code structure):
describe("Zorbling Management", () => {
  describe("Creating Zorblings", () => {
    it("should create zorbling with valid data", () => {
      // BDD: SIGNATURE
    });
    
    it("should reject zorbling with invalid data", () => {
      // BDD: SIGNATURE
    });
  });
});
```

**[DON'T]:**
* Add mocks, stubs, or helpers in signature phase
* Include implementation code or assertions
* Flatten hierarchy from scaffold
* Skip signature markers
* Change nesting structure from scaffold

```javascript
// Missing signature marker
it("should create zorbling", () => {
});

// Has implementation code (wrong for signature phase)
it("should create zorbling", () => {
  const zorbling = new Zorbling();
  expect(zorbling).not.toBeNull();
});
```

## 7. Test Implementation Phase Examples

When implementing tests from signatures (Phase 2: Write Tests), follow base rule § 8 principles with Jest-specific syntax:

**[DO]:**
* Use Arrange-Act-Assert structure with JavaScript syntax
* Mock using `jest.mock()` for modules or `jest.fn()` for functions - external boundaries only
* Extract setup to helper functions or `beforeEach()`
* Call production code directly - let tests fail naturally if code doesn't exist
* Replace `// BDD: SIGNATURE` markers with full implementation

```javascript
// From signature:
it("should create user with valid email", () => {
  // BDD: SIGNATURE
});

// To full test implementation:
it("should create user with valid email", () => {
  // Arrange
  const email = "test@example.com";
  const userData = { email, name: "Test User" };
  
  // Act
  const user = createUser(userData);
  
  // Assert
  expect(user.email).toBe(email);
  expect(user.isActive).toBe(true);
});
```

**[DON'T]:**
* Comment out production code calls
* Mock internal business logic
* Duplicate setup across sibling tests

```javascript
// DON'T: Commented out code
it("should create user", () => {
  // const email = "test@example.com";
  // const user = createUser({ email });
});

// DON'T: Mocking internal business logic
it("should validate user", () => {
  const mockUser = jest.fn();  // Don't mock the thing you're testing
  expect(mockUser.isValid()).toBe(true);
});
```

## 8. Code Implementation Phase Examples

When implementing production code from tests (Phase 3: Write Code), follow base rule § 9 principles with JavaScript-specific syntax:

**[DO]:**
* Implement minimal JavaScript code to make tests pass
* Use simple objects before creating classes
* Follow JavaScript conventions (ES6+)
* Return what tests expect, nothing more
* Let tests drive when you need classes or complexity

```javascript
// Test expects:
it("should create user with valid email", () => {
  const user = createUser({ email: "test@example.com", name: "Test" });
  expect(user.email).toBe("test@example.com");
  expect(user.isActive).toBe(true);
});

// Minimal implementation (start with object):
function createUser(userData) {
  const { email, name, role = "user" } = userData;
  
  if (!email || !email.includes("@")) {
    throw new Error("Invalid email format");
  }
  
  return {
    email,
    name,
    role,
    isActive: true
  };
}
```

**[DON'T]:**
* Add features not tested
* Create complex class structures prematurely
* Add configuration or options not tested

```javascript
// DON'T: Over-engineered with untested features
class User {
  constructor(email, name, role = "user", permissions = [], preferences = {}) {
    this.email = email;
    this.name = name;
    this.role = role;
    this.permissions = permissions;  // Not tested
    this.preferences = preferences;  // Not tested
    this.createdAt = new Date();     // Not tested
  }
  
  validatePermissions() {  // Not tested
    // ...
  }
  
  updatePreferences(prefs) {  // Not tested
    // ...
  }
}
```

## 10. Use ASCII-Only Characters in Test Code

**[DO]:**
Use plain ASCII text that works on all systems:
```javascript
console.log("PASS: Test passed");
console.log("SUCCESS: All assertions correct");
console.log("Next step:");
expect(result).toContain("correct the error");
```

**[DON'T]:**
Unicode characters crash on Windows console:
```javascript
console.log("✓ Test passed");
console.log("✅ All assertions correct");
console.log("→ Next step");
expect(result).toContain("→");
```

**Error:** Unicode encoding errors prevent tests from running on Windows and many CI/CD systems.

## Commands

Commands that implement or use this rule:

* `/bdd-validate` — Validate BDD test files against these principles
* `/bdd-workflow` — Execute BDD workflow phases (Domain Scaffold, Signatures, Write Tests, Write Code)
* `/bdd-scaffold` — Generate domain scaffolding (plain English hierarchy) from domain maps
* `/bdd-signature` — Generate test signatures (code structure) from scaffolds
* `/bdd-test` — Implement test code from signatures
* `/bdd-code` — Implement production code to make tests pass
