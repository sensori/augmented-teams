{
  "description": "Excessive guard clauses add to cyclomatic complexity and make code harder to read. Centralize error handling in one place rather than scattering defensive checks throughout the code. Let code fail fast with clear errors rather than silently handling missing components.",
  "examples": [
    {
      "do": {
        "description": "Centralize error handling and let code fail fast",
        "content": [
          "Assume components are properly initialized",
          "Let exceptions propagate to centralized error handlers",
          "Use type hints and contracts to document expectations",
          "Fail fast with clear error messages",
          "",
          "Correct Examples (no excessive guards):",
          "- Direct access: self.knowledge.instructions (assumes knowledge exists)",
          "- Direct property: self.behavior.bot_paths (assumes behavior exists)",
          "- Direct method call: file.read_text() (let it fail if file missing)",
          "",
          "Centralized Error Handling:",
          "- Handle errors at boundaries (API endpoints, CLI entry points)",
          "- Use decorators or middleware for common error handling",
          "- Let exceptions bubble up to appropriate handler",
          "- Document expected state in docstrings/type hints",
          "",
          "Fail Fast Principles:",
          "- Remove defensive checks that hide problems",
          "- Trust initialization and setup",
          "- Use assertions for invariants in development",
          "- Let type system catch errors where possible"
        ]
      },
      "dont": {
        "description": "Don't scatter defensive checks throughout code",
        "content": [
          "Don't check if every variable exists before using it",
          "Don't use hasattr() checks everywhere",
          "Don't check file.exists() before reading",
          "Don't check isinstance() defensively",
          "Don't check variable truthiness before every operation",
          "",
          "Wrong Examples (excessive guards):",
          "- if self.knowledge and self.knowledge.instructions: (assume knowledge exists)",
          "- if file.exists(): file.read() (let read fail if missing)",
          "- if hasattr(obj, 'attr'): obj.attr (assume attr exists)",
          "- if isinstance(obj, Type): obj.method() (trust type system)",
          "- Multiple if checks in same function for None/existence",
          "",
          "Excessive Guard Indicators:",
          "- Multiple if/None checks in same function",
          "- hasattr() checks before attribute access",
          "- File existence checks before file operations",
          "- isinstance() checks used defensively (not for polymorphism)",
          "- Variable truthiness checks before every operation",
          "- Guard clauses that silently return None/empty",
          "- Defensive checks that hide initialization problems",
          "",
          "Refactoring Strategies:",
          "- Remove guards and let code fail fast",
          "- Centralize error handling at boundaries",
          "- Use type hints to document expectations",
          "- Trust initialization and setup",
          "- Move error handling to appropriate layer",
          "- Use exceptions instead of silent failures"
        ]
      }
    }
  ],
  "scanner": "agile_bot.bots.base_bot.src.actions.validate.scanners.excessive_guards_scanner.ExcessiveGuardsScanner"
}

