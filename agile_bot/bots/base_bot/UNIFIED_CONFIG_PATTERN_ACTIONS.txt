================================================================================
CURRENT PATTERN - Actions, Behavior, Action (with separate config objects)
================================================================================

1. BEHAVIOR (uses BehaviorConfig)
--------------------------------------------------------------------------------
class Behavior:
    def __init__(self, name: str, bot_name: str, bot_paths: BotPaths, bot_instance=None):
        self.name = name
        self.bot_name = bot_name
        self.bot_paths = bot_paths
        self.bot = bot_instance

        self.behavior_config = BehaviorConfig(self.name, self.bot_paths, self.bot_name)
        
        self.description = self.behavior_config.description
        self.goal = self.behavior_config.goal
        self.inputs = self.behavior_config.inputs
        self.outputs = self.behavior_config.outputs

        self.guardrails = Guardrails(self.behavior_config)
        self.content = Content(self.behavior_config)
        self.rules = Rules(behavior=self, bot_paths=self.bot_paths)
        self.actions = Actions(self.behavior_config, self)
        self.trigger_words = TriggerWords(self.behavior_config)


2. BEHAVIORCONFIG (separate config class)
--------------------------------------------------------------------------------
class BehaviorConfig:
    def __init__(self, behavior_name: str, bot_paths: BotPaths, bot_name: str = None):
        self.behavior_name = behavior_name
        self.bot_paths = bot_paths
        self.bot_name = bot_name or ...
        
        self.behavior_directory = self.bot_paths.bot_directory / "behaviors" / behavior_name
        self.config_path = self.behavior_directory / "behavior.json"
        
        if not self.config_path.exists():
            raise FileNotFoundError(...)
        
        self._config = read_json_file(self.config_path)
    
    @property
    def actions_workflow(self) -> List[Dict[str, Any]]:
        actions = self._config.get("actions_workflow", {}).get("actions", [])
        if not isinstance(actions, list):
            return []
        return sorted(actions, key=lambda x: x.get("order", 0))


3. ACTIONS (receives behavior_config, extracts actions_workflow)
--------------------------------------------------------------------------------
class Actions:
    def __init__(self, behavior_config, behavior):
        self.behavior_config = behavior_config
        self.behavior = behavior
        self.bot_name = behavior.bot_name
        self.bot_paths = behavior.bot_paths
        
        actions_workflow = getattr(behavior_config, "actions_workflow", {})
        actions_list = actions_workflow.get('actions', []) if isinstance(actions_workflow, dict) else []
        
        self._actions: List[Action] = []
        for action_dict in actions_list:
            action_name = action_dict.get("name", "")
            if action_name:
                base_action_config = BaseActionConfig(action_name, self.bot_paths)
                if "order" in action_dict:
                    base_action_config._config["order"] = action_dict["order"]
                
                action_instance = self._instantiate_action(
                    action_name=action_name,
                    base_action_config=base_action_config,
                    behavior=behavior
                )
                self._actions.append(action_instance)
        
        self._current_index: Optional[int] = None
        self.load_state()


4. BASEACTIONCONFIG (separate config class)
--------------------------------------------------------------------------------
class BaseActionConfig:
    def __init__(self, action_name: str, bot_paths: BotPaths):
        self.action_name = action_name
        self.bot_paths = bot_paths
        
        base_actions_dir = get_base_actions_directory(bot_directory=bot_paths.bot_directory)
        
        self.config_path = base_actions_dir / action_name / "action_config.json"
        
        if self.config_path.exists():
            self._config = read_json_file(self.config_path)
            self._config['name'] = action_name
        else:
            self._config = {
                "name": action_name,
                "workflow": True,
                "order": 0
            }
    
    @property
    def order(self) -> int:
        return self._config.get("order", 0)
    
    @property
    def next_action(self) -> Optional[str]:
        return self._config.get("next_action")
    
    @property
    def custom_class(self) -> Optional[str]:
        return self._config.get("action_class") or self._config.get("custom_class")
    
    @property
    def instructions(self) -> list:
        return self._config.get("instructions", [])
    
    @property
    def workflow(self) -> bool:
        return self._config.get("workflow", True)


5. ACTION (uses BaseActionConfig)
--------------------------------------------------------------------------------
class Action:
    def __init__(self, base_action_config=None, behavior=None, 
                 bot_name: str = None, action_name: str = None):
        if base_action_config is not None:
            if behavior is None:
                raise ValueError("behavior is required when base_action_config is provided")
            self.base_action_config = base_action_config
            self.behavior = behavior
            self.bot_name = behavior.bot_name
            self.action_name = base_action_config.action_name
        elif bot_name is not None and action_name is not None:
            self.bot_name = bot_name
            self.behavior = behavior
            self.action_name = action_name
            from agile_bot.bots.base_bot.src.actions.base_action_config import BaseActionConfig
            if behavior is None or behavior.bot_paths is None:
                raise ValueError("behavior and behavior.bot_paths are required")
            self.base_action_config = BaseActionConfig(action_name, behavior.bot_paths)
        else:
            raise ValueError("Either base_action_config must be provided, or both bot_name and action_name")
        
        from agile_bot.bots.base_bot.src.actions.activity_tracker import ActivityTracker
        self._activity_tracker = ActivityTracker(self.bot_paths, self.bot_name)
        
        self.order = self.base_action_config.order
        self.action_class = self.base_action_config.custom_class
        self.instructions = self._load_and_merge_instructions()


================================================================================
FLOW SUMMARY
================================================================================

1. Behavior creates BehaviorConfig → loads behavior.json
2. Behavior creates Actions(behavior_config, self) → passes BehaviorConfig
3. Actions extracts actions_workflow from behavior_config
4. Actions creates BaseActionConfig for each action → loads base action config
5. Actions creates Action(base_action_config, behavior, ...) → passes BaseActionConfig
6. Action uses base_action_config to access config properties

Issues:
- BehaviorConfig is separate object, Behavior just wraps it
- BaseActionConfig is separate object, Action just wraps it
- Redundant config loading (BehaviorConfig loaded, then Behavior accesses it)
- Actions receives behavior_config instead of behavior directly


================================================================================
PROPOSED UNIFIED PATTERN - Merge configs into main objects
================================================================================

1. BEHAVIOR (loads its own config, no BehaviorConfig)
--------------------------------------------------------------------------------
class Behavior:
    def __init__(self, name: str, bot_paths: BotPaths, bot_instance=None):
        self.bot_name = bot_paths.bot_directory.name
        self.name = name
        self.bot_paths = bot_paths
        self.bot = bot_instance
        
        self.behavior_directory = self.bot_paths.bot_directory / "behaviors" / name
        self.config_path = self.behavior_directory / "behavior.json"
        
        if not self.config_path.exists():
            raise FileNotFoundError(
                f"Behavior config not found at {self.config_path}. "
                "Each behavior must define its own behavior.json."
            )
        
        self._config = read_json_file(self.config_path)
        
        self.description = self._config.get("description", "")
        self.goal = self._config.get("goal", "")
        self.inputs = self._config.get("inputs", [])
        self.outputs = self._config.get("outputs", [])
        self.instructions = self._config.get("instructions", {})
        self.trigger_words = self._config.get("trigger_words", [])
        self.order = self._config.get("order", 999)
        
        self.guardrails = Guardrails(self)
        self.content = Content(self)
        self.rules = Rules(behavior=self, bot_paths=self.bot_paths)
        
        self.actions = Actions(self)
        
        self.trigger_words_obj = TriggerWords(self)
    
    @property
    def folder(self) -> Path:
        return self.behavior_directory


2. ACTIONS (extracts actions from behavior._config directly)
--------------------------------------------------------------------------------
class Actions:
    def __init__(self, behavior: 'Behavior'):
        self.behavior = behavior
        
        actions_workflow = behavior._config.get("actions_workflow", {})
        actions_list = actions_workflow.get("actions", [])
        
        actions_list = sorted(actions_list, key=lambda x: x.get("order", 0))
        
        self._actions: List[Action] = []
        for action_dict in actions_list:
            action_name = action_dict.get("name", "")
            if action_name:
                action_instance = self._create_action_instance(
                    action_name=action_name,
                    behavior=behavior,
                    action_config=action_dict
                )
                self._actions.append(action_instance)
        
        self._current_index: Optional[int] = None
        self.load_state()
    
    def _create_action_instance(self, action_name: str, behavior: 'Behavior',
                               action_config: Dict[str, Any]) -> Action:
        import importlib
        
        custom_class = action_config.get("action_class") or action_config.get("custom_class")
        
        if not custom_class:
            base_actions_dir = get_base_actions_directory()
            action_config_path = base_actions_dir / action_name / "action_config.json"
            if action_config_path.exists():
                base_config = read_json_file(action_config_path)
                custom_class = base_config.get("action_class") or base_config.get("custom_class")
        
        action_class_path = custom_class
        if not action_class_path:
            action_module_mapping = {
                'clarify': ('clarify', 'clarify_action', 'ClarifyContextAction'),
                'strategy': ('strategy', 'strategy_action', 'StrategyAction'),
                'decide_strategy': ('strategy', 'strategy_action', 'StrategyAction'),
                'build': ('build', 'build_action', 'BuildKnowledgeAction'),
                'build_knowledge': ('build', 'build_action', 'BuildKnowledgeAction'),
                'validate': ('validate', 'validate_action', 'ValidateRulesAction'),
                'render': ('render', 'render_action', 'RenderOutputAction'),
                'render_output': ('render', 'render_action', 'RenderOutputAction'),
            }
            mapping = action_module_mapping.get(action_name)
            if mapping:
                module_name, module_file, action_class_name = mapping
                action_class_path = f"agile_bot.bots.base_bot.src.actions.{module_name}.{module_file}.{action_class_name}"
            else:
                module_name = action_name
                action_class_name = action_name.title().replace('_', '') + 'Action'
                action_class_path = f"agile_bot.bots.base_bot.src.actions.{module_name}.{module_name}_action.{action_class_name}"
        
        module_path, class_name = action_class_path.rsplit(".", 1)
        try:
            module = importlib.import_module(module_path)
        except ModuleNotFoundError as e:
            raise ValueError(
                f"Action '{action_name}' cannot be loaded: module '{module_path}' not found. "
                f"Expected path: {action_class_path}"
            ) from e
        
        try:
            action_class = getattr(module, class_name)
        except AttributeError as e:
            raise ValueError(
                f"Action '{action_name}' cannot be loaded: class '{class_name}' not found in module '{module_path}'. "
                f"Expected class: {action_class_path}"
            ) from e
        
        return action_class(
            action_name=action_name,
            behavior=behavior,
            action_config=action_config
        )


3. ACTION (loads its own base config, merges with action_config from behavior.json)
--------------------------------------------------------------------------------
class Action:
    def __init__(self, action_name: str, behavior: 'Behavior', 
                 action_config: Dict[str, Any] = None):
        self.action_name = action_name
        self.behavior = behavior
        
        from agile_bot.bots.base_bot.src.actions.activity_tracker import ActivityTracker
        self._activity_tracker = ActivityTracker(behavior.bot_paths, behavior.bot_name)
        
        base_actions_dir = get_base_actions_directory()
        base_config_path = base_actions_dir / action_name / "action_config.json"
        
        if base_config_path.exists():
            self._base_config = read_json_file(base_config_path)
            self._base_config['name'] = action_name
        else:
            self._base_config = {
                "name": action_name,
                "workflow": True,
                "order": 0
            }
        
        if action_config:
            if "order" in action_config:
                self._base_config["order"] = action_config["order"]
            if "instructions" in action_config:
                behavior_instructions = action_config["instructions"]
                base_instructions = self._base_config.get("instructions", [])
                self._base_config["instructions"] = self._merge_instructions(
                    base_instructions, behavior_instructions
                )
            if "action_class" in action_config or "custom_class" in action_config:
                self._base_config["custom_class"] = action_config.get("action_class") or action_config.get("custom_class")
            if "next_action" in action_config:
                self._base_config["next_action"] = action_config["next_action"]
        
        self.order = self._base_config.get("order", 0)
        self.next_action = self._base_config.get("next_action")
        self.custom_class = self._base_config.get("action_class") or self._base_config.get("custom_class")
        self.workflow = self._base_config.get("workflow", True)
        
        self.instructions = self._base_config.get("instructions", [])
    
    def _merge_instructions(self, base_instructions, behavior_instructions) -> List:
        if isinstance(base_instructions, list) and isinstance(behavior_instructions, list):
            return base_instructions + behavior_instructions
        elif isinstance(base_instructions, list):
            return base_instructions + [behavior_instructions] if behavior_instructions else base_instructions
        else:
            return behavior_instructions if behavior_instructions else base_instructions
    
    @property
    def base_actions_dir(self) -> Path:
        return get_base_actions_directory()


================================================================================
PROPOSED FLOW SUMMARY
================================================================================

1. Behavior loads behavior.json → stores as self._config
2. Behavior creates Actions(self) → passes self (Behavior)
3. Actions receives Behavior, extracts actions_workflow.actions from behavior._config
4. Actions creates Action objects, passing each action_config dict
5. Action loads base config from Base Bot area, merges with action_config from behavior.json

Key Changes:
- Behavior loads its own config (no BehaviorConfig)
- Behavior creates Actions object directly (self.actions = Actions(self))
- Actions extracts actions list from behavior._config directly (no intermediate _actions_config)
- Action loads its own base config (no BaseActionConfig)
- Action merges base config with action_config from behavior.json
- Base actions always from Base Bot area (get_base_actions_directory() with no params)

