================================================================================
DOMAIN DRIVEN DESIGN TRAINING - SLIDE BY SLIDE EXTRACTION
================================================================================


================================================================================
SLIDE 1
================================================================================

Story and Domain Driven DeliveryMarch 28, 2021Jeff Anderson, Adeeb Dhanani,Margaret Walczyk & Malcolm Bastien



================================================================================
SLIDE 2
================================================================================

Introduction



================================================================================
SLIDE 3
================================================================================

Our delivery model makes heavy reference to the following three practices

Workflow based sequence of events, usually persona based, we tend to use it as logical system events.  Also knowns as a 2 dimensional backlog or Light-weight scope on a wall.

Ubiquitous language between Business and Technology.  The inter-connected relationships between concepts at a logical level.

Also known as Behaviour Driven Design.  Defining Stories, Features, Epics, or Scenarios using plain language in a structured format with Real Examples.  Illustrating the Inputs, Trigger, and expected Results of a Story

User Story Mapping

By Jeff Patton

Domain-Driven Design

By Eric Evans

Specification by Example

By Gojko Adzic

https://bit.ly/2SxmWqJ

Mastering these practices will allow you to excel in the craft of solution scoping,  definition, design, and testing in a modern, agile context;  reading these texts is highly recommend

[IMAGE(S) FOR THIS SLIDE]
--------------------------------------------------------------------------------
  Image: slide_003_image_1.png
  Location: images/slide_003_image_1.png



================================================================================
SLIDE 4
================================================================================

The Heart Of Solution Complexity Is In Its Business Domain

When solution complexity gets out of hand, the software can no longer be easily changed or extended.

But a good design can make opportunities out of a complex feature domains.

Our developers have a wealth of skills when it comes to designing  the Technological aspects of a system.

Yet the most significant complexity of many applications is not technical, it is in the domain itself, the activity or business of the user.

When this domain complexity is not dealt with in the software design, it won't matter that the technology internals are well-conceived.

As part of standing up our teams, our aim is to supplement your teams existing agile delivery knowledge with the skills required to design, develop, and test according to the principles of Domain Driven Design

[IMAGE(S) FOR THIS SLIDE]
--------------------------------------------------------------------------------
  Image: slide_004_image_1.jpg
  Location: images/slide_004_image_1.jpg



================================================================================
SLIDE 5
================================================================================

Domain Driven Design tackles solution complexity by focusing on the details of the business domain

Key Principles

Capture the domain model, in domain terms, through frequent interaction with domain experts

Embed the domain terminology into your code

Separate all domain logic from corruption

Frame all dialogue about the solution in terms of the model, forming a Ubiquitous Language

Divide the domain into separate sub-domains, separated by bounded contexts

Tight collaboration between technical and domain experts

Divide the domain into separate Bounded Contexts built by different teams

Tightly aligns models, language and business logic code

Results in a Ubiquitous Language

Domain Driven Design tightly aligns the software solution with the business problem

Repository

Service

Bounded Context



================================================================================
SLIDE 6
================================================================================

Domain Driven Design provides a framework to guide the design decisions required to define the boundary, scope and interactions of a modern, microservices based solution

We can conduct Domain Analysis for each sub system, defining the service, domain aggregate, and domain events

We can use EventStorming to explore your domain flow,  mapping major domain events, reactions to those events, and domain commands

We can group domain concepts into discrete Bounded Contexts, mapping out our ecosystem of sub systems



================================================================================
SLIDE 7
================================================================================

The Ubiquitous Language



================================================================================
SLIDE 8
================================================================================

Domain Driven Design provides a means for Technology and Product to come together to design a solution around its business domain logic

Domain Driven Design A Software Design approach that focuses the modelling, communication, and development on the core business domain logic of a solution

Use Domain Driven Design to guide the design and build of your Microservice solution with agility and at scale

Product Analysts extend structured story definition techniques to explore, capture, and model domain details

Technology leverage service and object oriented design to refines domain models and incorporate domain concepts directly into code with a minimum of translation.

Product Owners  provide domain subject matter expertise to design and validate that our domain logic reflect the business



================================================================================
SLIDE 9
================================================================================

Language, Models, and Code all meet in the Domain layer of a software solution

DDD is a structured way to create a Ubiquitous Language

We model the language of the business, in a structure easily represented in code

Describes business concepts, business state, and business rules

Enables reusable acceptance criteria when connecting multiple domain concepts (end-to-end testing!)

May be illustrated using CRC (Class-Responsibility-Collaborator) Cards or plain old UML

One model for the code, the diagrams, and the language people use!

[IMAGE(S) FOR THIS SLIDE]
--------------------------------------------------------------------------------
  Image: slide_009_image_1.png
  Location: images/slide_009_image_1.png



================================================================================
SLIDE 10
================================================================================

Perhaps the most powerful aspect of Domain Driven Design is the definition and sharing of a Ubiquitous Language

The Model

The Conversation

And Yes, The Code

How do we want to treat Cars differently from vehicles in general?

For cars we are concerned with passengers and fuel…

Hey I think I can understand what these guys are talking about…

Historically, technology and the business have spoken entirely different languages, interfering with collaboration, blocking understanding, and impeding progress

[IMAGE(S) FOR THIS SLIDE]
--------------------------------------------------------------------------------
  Image: slide_010_image_1.png
  Location: images/slide_010_image_1.png



================================================================================
SLIDE 11
================================================================================

DDD stated simply; holding a conversation rooted in a domain model, that is reflected in the domain layer of your code

A Program represents all program information maintained by OSAP for each Educational Institution.

Students enrolled in a Programs do not have Eligibility to apply for specific Funding Instruments.

Funding Instruments Eligibility for a Program is determined by the Educational Institution providing the Program. Each Program has a set of Program Costs that are either Fixed, Flexible or Student Centric.

A Program may be defined by a Student when making an Application for a specific Course. This will set the type of Program Cost to Student Centric.

The resulting Student Centric Program would be associated with the Student and the Application that created it.

The Conversation

The Model

The Code

[IMAGE(S) FOR THIS SLIDE]
--------------------------------------------------------------------------------
  Image: slide_011_group_image_1.png
  Location: images/slide_011_group_image_1.png
  Image: slide_011_image_1.png
  Location: images/slide_011_image_1.png



================================================================================
SLIDE 12
================================================================================

Exercise:  Take 30 minutes and collaborate on a ubiquitous language

Take the thin-slice we have gone through

Build your ubiquitous language by creating the following:

A write up in plain English

A model representing the write up, in any format you want

Some scaffolding code, focused on representing the operations and relationships expressed in the model and the writeup

Each team be ready to spend 5 minutes showing your results!

PAs bring structured thinking, Developers express in Code, POs bring your business knowledge.



================================================================================
SLIDE 13
================================================================================

Modelling Domains Using CRC Cards



================================================================================
SLIDE 14
================================================================================

Class Responsibility Cards provide a way to model in an object-oriented way using natural, business friendly language

Each discrete part of the domain is captured using  a “Class” (or Concept) Card

We want to assign behaviour and information to each Class, we capture these as distinct Responsibilities

Classes are almost never an island onto their own, Classes need to interact with other Classes to fulfill their Responsibilities, these are listed as Collaborators beside the associated Responsibility

A specific Class can be derived from a more generic Class, this lets us define concepts that apply to more than one situation

The biggest value of CRC cards is to allow people to break away from the procedural mode of thought and more fully appreciate object technology.

http://www.extremeprogramming.org/rules/crccards.html

CRC cards provide a highly collaborative mechanism for business and technology subject matter experts to collectively understand their business domain and how it will be expressed as a solution

Jeff & Adeeb



================================================================================
SLIDE 15
================================================================================

The Classic Vehicle Example

A CRC model gives you structure that can be applied to your solution (UI, Database, services, etc…)

A Vehicle Drives Passengers, a collection of Persons (People?) from place to place

A Person May be A Passenger in a Vehicle at any given time (or not)

A Vehicle is Driven by a Driver

A Driver is a type of Person that Drives a Vehicle using Steering, Gas, and Breaks

Driving a Vehicle causes it to Turn, Accelerate, or Decelerate

A Plane is a type of Vehicle

A Plane is Piloted by a type of Driver called a Pilot

A Pilot Pilots a Plane using a Flight Stick and Rudder Pedals

A Plane Ascends or Descends when a Pilot uses their Flight Stick to interact with the Plane’s Elevators

A Plane is stabilized when a Pilot uses their Rudder Pedals to interact with the Plane’s Rudder

A Plane Rolls when a Pilot uses their Flight Stick to interact with the Plane’s Ailerons

A CRC model gives you language; plain sentences that can be verified (or not) by domain experts:

0..*

0..1

is Driven                          Driver

Turns                                Steering, Wheels, Driver

Accelerates and Decelerates

Gas, Pedal, Driver

Is Piloted                         Pilot

Ascends / Descends     Flight Stick, Elevator,

Pilot

Stabilizes                        Rudder Pedals, Rudder

Roll                                  Aileron, Flight Stick



================================================================================
SLIDE 16
================================================================================

Perform The Iterative Steps of CRC Modeling

Going through the thin-slice, identify key domain concept, the key entities, key actors, state, etc.

Create new CRC card for each concept

Use one or two words to describe the class

Create Class names in the Form of A Nested Concept

Identify

Taking a second pass on the thin-slice, ask probing questions and explore the meaning of each Class

Is the class a true first-class domain concept, or is it part of something else

What are the classes key responsibilities, what does it do, what do we do with it? What core information does it have?

For each responsibility identify collaborators, potentially creating new classes to fulfill responsibilities

Use action-oriented Action Subject language for each responsibility

Explore

Walk

Once the CRC model has been battle-tested, translate the model into domain code!

Transcribe each CRC card into a class, operations into methods and/or properties, and required relationships into constructors

Continue to ask domain related questions made obvious as you start putting some code down

Refine your model to reflect new learning or decisions made while coding!

Code

Please See Miro Example

https://miro.com/app/board/o9J_kvfvWeY=/?moveToWidget=3074457356449611848&cot=14

Going through our thin-slice a final time, for each story, walk through the CRC model to validate the domain model supports each story

Start with first CRC card required to support the story being walked

Find the responsibility that fulfills the requirements of the story

For each collaborator listed in the responsibility found, continue tracing through the right responsibility and its associated collaborator

Refine the model as required



================================================================================
SLIDE 17
================================================================================

Exercise: Take an Hour and Model The Domain Of Your Thin Slice Using CRC Cards

Take the Thin Slice From Your Previous Example

Refine your Ubiquitous Language Through CRC Modelling

Identify

Explore

Walk

Code!

Each team be ready to spend 10 minutes showing your results!



================================================================================
SLIDE 18
================================================================================

DDD Training - Session 2 Thin Slice Shaping Agenda

Review each Team’s Domain Model

Thin-slice Shaping

Completing our Functional Story Map

Exercise 1: Thin-slice Shaping Exercise

Refine Key Domain Concepts

Exercise 2: Walk the Model and update the Story Map

Aggregate, Roots, Entities, and Bounded Contexts

Exercise 3: Entities and Value Objects

Exercise 3b: Aggregates

Exercise 3c: Bounded Context

Session 3: Sub System Shaping

Event Storming

Bounded Context Maps In Detail



================================================================================
SLIDE 19
================================================================================

Thin-slice Shaping



================================================================================
SLIDE 20
================================================================================

VPHX uses Kanban to manage how work items flow through our system, from idea to customer

Define testable thin slices

Outline key domains and entities

Refine story map

Create thin-slice acceptance criteria

Add system stories

Estimate story counts

Identify bounded contexts

EventStorming to define flow across contexts

Create bounded context map

Add stories to Jira

Add stories to confluence

Complete story acceptance criteria

Develop stories using TDD

Track flow

Refine entities and value objects

Define domain internals

Test all story acceptance criteria

Test thin-slice acceptance criteria

Perform regression test

VPHX Program Kanban to Manage Workflow



================================================================================
SLIDE 21
================================================================================

Goal: Create a fully estimated thin-slice complete with scenarios and acceptance criteria, refined to include system stories.

Key Activities

Refine the thin-slice story map with system stories

Define thin-slice scenarios and acceptance criteria

Add thin-slice to Jira

Identify bounded context & aggregates

Estimate total story count for thin-slice

Create cumulative flow diagram and forecast

Key Practices

Story mapping

Thin-slicing

Estimating

Forecasting

Cumulative flow diagram

A Recap on Thin-slice Shaping

Key Tools

Miro

Jira

Key Participants

Product Owner

Product Analysts

Tech pair



================================================================================
SLIDE 22
================================================================================

Completing Our Functional Story Map



================================================================================
SLIDE 23
================================================================================

Who are the users?

What are they trying to do?

What are the steps?

What is new or is changing in functionality?

Program Story Map to Align and Visualize

We use story mapping align on scope, visualize and break down different features into smaller units of work



================================================================================
SLIDE 24
================================================================================

Example: Enhanced Pickup

[IMAGE(S) FOR THIS SLIDE]
--------------------------------------------------------------------------------
  Image: slide_024_image_1.png
  Location: images/slide_024_image_1.png



================================================================================
SLIDE 25
================================================================================

Example: Scanning Non-RX Documents

TS1

TS2

TS3

[IMAGE(S) FOR THIS SLIDE]
--------------------------------------------------------------------------------
  Image: slide_025_image_1.png
  Location: images/slide_025_image_1.png



================================================================================
SLIDE 26
================================================================================

We use thin-slicing to break down large work initiatives into smaller increments that can be built and tested end-to-end

Thin-Slice to Breakdown Project Milestones

Dispense New/Existing Prescription

Renew Prescription

Pharmacy Staff

Login

RX Intake

Validate Renewal

Notify Prescriber

RX Dispense

MVP

What are Thin-slices?

A way to breakdown a large initiative into smaller groups of stories

These groups of stories can span multiple features or teams.

Thin-slices are testable and potentially deployable, with recognizable user value.

Why Thin-slices?

Reduce the batch size of work

Reduce work in progress

Deliver a small bit of functionality faster

Increase the speed of customer feedback

Measure and improve end-to-end workflow

Good Thin Slices:

Cross all application layers

Business observable behaviour

Integration tested within 6 weeks

Thin-slice



================================================================================
SLIDE 27
================================================================================

Specifications

Thin-slice Shaping Exercise:

Review our thin-slice story map and complete it for functional scope.

Review the thin-slice story map on Miro.

Complete the story map by adding any mission functional stories

These are behaviours that domain experts can understand

Not technical tasks or events

Identify questions, comments and assumptions.

Estimate the total story count for each epic

Functional stories



================================================================================
SLIDE 28
================================================================================

Refine Key Domain Concepts



================================================================================
SLIDE 29
================================================================================

The Example Which Will Be Used To Illustrate How We Can Elaborate On Our Domain Through Our Delivery Lifecycle

Scenario Title:

Create a New “Teen Choice Plan”

Scenario Shaping:

Voice 500 Mins

3000 SMS/MMS

1 GB Data

[IMAGE(S) FOR THIS SLIDE]
--------------------------------------------------------------------------------
  Image: slide_029_image_1.png
  Location: images/slide_029_image_1.png



================================================================================
SLIDE 30
================================================================================

Discussing Key Domain Concepts During Thin Slice Shaping

Acceptance Criteria

Scenario: Create a New “Teen Choice Plan” with Voice 500 Mins, 3000 SMS/MMS, 1 GB Data



================================================================================
SLIDE 31
================================================================================

Start with Capturing Key Words From The Story Map

Identify the Key Words within the Story Map.

Ask the team what do these key words mean?

And how do they relate?

Scenario: Create a New “Teen Choice Plan” with Voice 500 Mins, 3000 SMS/MMS, 1 GB Data

[IMAGE(S) FOR THIS SLIDE]
--------------------------------------------------------------------------------
  Image: slide_031_image_1.png
  Location: images/slide_031_image_1.png



================================================================================
SLIDE 32
================================================================================

Build the Domain Using the Story Map

Scenario: Create a New “Teen Choice Plan” with Voice 500 Mins, 3000 SMS/MMS, 1 GB Data

Define Products

Define Product Catalogue

Product Managers

Configure Plans for Products

Acceptance Criteria

Is charged based on Chargeable Items

Chargeable Items

Is a Collection of Price Items

Price Items

[IMAGE(S) FOR THIS SLIDE]
--------------------------------------------------------------------------------
  Image: slide_032_image_1.png
  Location: images/slide_032_image_1.png



================================================================================
SLIDE 33
================================================================================

Rebuild Story Map To Compliment Domains

Scenario: Create a New “Teen Choice Plan” with Voice 500 Mins, 3000 SMS/MMS, 1 GB Data

Define Products

Define Product Catalogue

Product Managers

Configure Plans for Products

Is charged based on Chargeable Items

Chargeable Items

Is a Collection of Price Items

Price Items

[IMAGE(S) FOR THIS SLIDE]
--------------------------------------------------------------------------------
  Image: slide_033_image_1.png
  Location: images/slide_033_image_1.png



================================================================================
SLIDE 34
================================================================================

Glimpse Of Expanded Domain Model To Spec

Please see https://miro.com/app/board/o9J_kvfvWeY=/?moveToWidget=3074457356476780707&cot=14

[IMAGE(S) FOR THIS SLIDE]
--------------------------------------------------------------------------------
  Image: slide_034_image_1.png
  Location: images/slide_034_image_1.png



================================================================================
SLIDE 35
================================================================================

Actual Domain Model & Story Map

[IMAGE(S) FOR THIS SLIDE]
--------------------------------------------------------------------------------
  Image: slide_035_image_1.jpg
  Location: images/slide_035_image_1.jpg
  Image: slide_035_image_1.png
  Location: images/slide_035_image_1.png



================================================================================
SLIDE 36
================================================================================

Domain Model in progress…

[IMAGE(S) FOR THIS SLIDE]
--------------------------------------------------------------------------------
  Image: slide_036_image_1.jpg
  Location: images/slide_036_image_1.jpg
  Image: slide_036_image_1.png
  Location: images/slide_036_image_1.png



================================================================================
SLIDE 37
================================================================================

Specifications

Exercise: Take 90 mins Walk the domain model and update the story map

Walk your domain model

Compare the steps you walked to the story map

Update the story map with the same language of your domain model

Update the story map to include any missing stories

Each team be ready to spend 10 minutes showing their results!



================================================================================
SLIDE 38
================================================================================

Aggregate, Roots, Entities, and Bounded Contexts



================================================================================
SLIDE 39
================================================================================

DDD Provides a Means to Partition Business Logic According In The Model and the Code

Patient

Pick Up Method

Address

Entities

Have an identity that remains the same regardless of changes to specific data. Are the primary domain concepts we care about

We identify a Unique Patient In The System by their PHIN, and through a unique combination of Address, Name, and Phone

Value Objects

Are attributes, they do not have any inherent identity, and shared by many different Entities, considered Read Only

The parts of the system can we assume are immutable include Pick Up Methods and Addresses…

Clinical Information

Insurance

Aggregates

A grouping of closely associated objects that should be treated as a single unit for the purpose of data access and changes, defined in terms of roots that are directly accessible, and boundaries

We access all Patient Information directly through the Patient

Services

Gatekeeper to accessing business logic for a particular domain, services control/encapsulate business rules, business logic and business validation for a particular domain

The public operations for Patient that we want to expose to the rest of the system include Search, Merge, …

Patient Service

Repository

Represents the persistence layer required to search/access/ modify domain objects, Repositories are a simple and business specific interface for all operations on stored data

We can search for Patients by any combination of PHIN, Fname, Lname, Address, …

Patients

Events

The Conditions and state changes that happen within the Payments Domain that are made available for the rest of the system to consume. Most integrations across Contexts should occur asynchronously through Events

Events are raised whenever Patients change their Address, Insurance, Pickup Method…

Patient Created

Patient Merged

Bounded Context

Is a boundary explicitly set where the details of a subset of the domain is consistent and uniformly true. Consistency is expected to be true for the business domain language, domain model, and domain code, for a domain focused team.

The way we represent Patients and all of it’s internal will be consistent for every one working on the Payments Module

Each Domain Artifact Is Built Through Deep Understanding Of The Business Domain

Patient Bounded Context



================================================================================
SLIDE 40
================================================================================

Entities have Identities that Transcend The Value of Their Attributes

Patient

Pick Up Method

Address

Have an identity that remains the same regardless of changes to specific data.

The primary concepts that are core to the domain

One of the first things we want to do  in DDD is key on the terms in our Ubiquitous Language that exhibit a common thread of identity

Clinical Information

Insurance

Patient Service

Patients

Patient Created

Patient Merged

Questions That Only The Business Can Answer Regarding Entities

If two instances of a thing (Person, Product, etc) have the same name, are they automatically the same thing?

What business concepts are identified by more than the value of their attributes?

What attributes, or rules can we use to establish /verify the identity of a thing?

If two instances of the same object have different attribute values, but same identity value, are they the same entity?

Developers use Entities to explicitly capture concerns relating to identity, and the lifecycle of identity

Patient Bounded Context

Please see https://miro.com/app/board/o9J_kvfvWeY=/?moveToWidget=3074457356476780707&cot=14



================================================================================
SLIDE 41
================================================================================

Value Objects are simpler, read-only,  and are shareable across the system

Patient

Pick Up Method

Address

Have no identity beyond the attributes they possess

We don’t care about the extra complexity required to manage identity

One of the first things we want to do in DDD is key on the terms in our Ubiquitous Language that exhibit a common thread of identity

Clinical Information

Insurance

Patient Service

Patients

Patient Created

Patient Merged

Questions That Only The Business Can Answer Regarding Value Objects

What business concepts are identified by more than the value of their attributes?

What attributes, or rules can we use to establish /verify the identity of a thing?

Defining Value Objects allows developers to greatly simplify parts of the system through implementation of side effect free functions

Patient Bounded Context



================================================================================
SLIDE 42
================================================================================

Design Constraints When Developing Entities and Value Object

Entities should have an operation that is guaranteed to produce a unique result that will identify the object within the system..

The interface of an entity should be reduced to

those operations and attributes necessary to identify or search for it/match its identity

to coordinate the operations of the objects that they own.

Factor out all other behavior to “owned” objects

Value objects should be treated as immutable. This helps us to optimize performance as we can now safely share value objects.

A Value object may also safely pass attributes to another object without worrying about it being unsafely modified and possibly corrupting the owner.

Design value objects so that they are never changed; rather they are created and possibly replaced

Please see https://miro.com/app/board/o9J_kvfvWeY=/?moveToWidget=3074457356476780707&cot=14

Value Objects

Entities

[IMAGE(S) FOR THIS SLIDE]
--------------------------------------------------------------------------------
  Image: slide_042_image_1.png
  Location: images/slide_042_image_1.png



================================================================================
SLIDE 43
================================================================================

Exercise: Revisit our model and identify Entities and Value Objects

Which elements require thoughtful identity management?

Which elements are really just fancy primitives?



================================================================================
SLIDE 44
================================================================================

Aggregates are a tight collection of objects that are treated as a single unit when undergoing any changes in state

Patient

Pick Up Method

Address

An aggregate is a collection of objects that represent a single concept

All objects inside an aggregate can only be accessed through a pre-defined Root

All objects that are associated with the Root can only be updated/deleted/etc together, ie they are treated as single concept

When object relationships exists across aggregates we must consider how to keep changes synchronized across aggregates

Clinical Information

Insurance

Patient Service

Patients

Patient Created

Patient Merged

Questions That Only The Business Can Answer Regarding Aggregates

Which parts of our domain can we directly access?

Which domain concepts get updated together as a single cohesive unit? Which domain concepts get updated separately?

When / How frequently do we coordinate updates made to aggregates that have relationships to other aggregates?

What attributes, or rules can we use to establish /verify the identity of a thing?

If two instances of the same object have different attribute values, but same identity value, are they the same entity?

Aggregates allows developers to design both data integrity and service integration according to the specific business criteria

Patient Bounded Context

Root



================================================================================
SLIDE 45
================================================================================

Design Constraints When Developing Aggregates

An aggregate is an abstraction used to represent a cluster of associated objects that should be treated as a single unit for the purpose of data changes.

Each aggregate has a root and a boundary.  The root of the aggregate is a single, specific entity.

The root is the only member of the aggregate that outside objects are allowed to hold a persistent reference to

Code outside of an aggregate boundary can only load/save/delete/create an aggregate through its root Entity

Invariants are consistency rules that must be maintained whenever data changes

The root has a global identity and is responsible for all invariant checking

When any change to an aggregate boundary is committed, all invariants must be satisfied

Entities within the boundary of an aggregate have a local identity, and are unique within the aggregate

Delete operations must remove everything within the aggregate boundary at once

[IMAGE(S) FOR THIS SLIDE]
--------------------------------------------------------------------------------
  Image: slide_045_image_1.png
  Location: images/slide_045_image_1.png



================================================================================
SLIDE 46
================================================================================

A Simple Example:

Parts are used by many POs

Parts change less often than POs

Changes to the prices of a part do not necessarily propagate to existing POs.  This depends on the time that the price was changed relative to the status of the PO

Please see https://miro.com/app/board/o9J_kvfvWeY=/?moveToWidget=3074457356476780707&cot=14

[IMAGE(S) FOR THIS SLIDE]
--------------------------------------------------------------------------------
  Image: slide_046_image_1.png
  Location: images/slide_046_image_1.png



================================================================================
SLIDE 47
================================================================================

Exercise: Revisit our model and identify Aggregates

Which elements do we directly access and which elements change with them?

Where in our model should element changes not occur In real time?



================================================================================
SLIDE 48
================================================================================

A Bounded Context defines where the details of subset of our Domain is set to be consistent and true

Patient

Pick Up Method

Address

A hard boundary that is explicitly managed so that all concepts within it are kept consistent.

Pertains to all artifacts inside the boundary, the model, the language, and the code

Often a one-to-one match to a team, ie a team operates and owns one bounded context

Many systems operate across multiple organizational and solution specific Bounded Contexts.

We illustrate how to translate across these contexts by using a Bounded Context Map

Clinical Information

Insurance

Patient Service

Patients

Patient Created

Patient Merged

Questions That Only The Business Can Answer Regarding Bounded Contexts

Where in our organization / teams / solutions do similar concepts get represented in different ways, or where the same terms can mean different things?

How do we resolve dependencies between domain elements that exist across multiple contexts?

What parts of our domain can be thought in a truly independent way?

Bounded Contexts allow us to deliver completely decoupled sub systems according to our organizational our intended org structure.

Patient Bounded Context

Please see https://miro.com/app/board/o9J_kvfvWeY=/?moveToWidget=3074457356476780707&cot=14



================================================================================
SLIDE 49
================================================================================

Exercise: Revisit our model and identify Bounded Contexts

Which parts of the business can be thought of in a highly decoupled way?



================================================================================
SLIDE 50
================================================================================

Exercise: Clean Up

Focus on

Refine the Language in the classes for the responsibilities

Make sure the lines connecting to the cards have the appropriate collaborators

Identify any missing Entities, Value Objects, Roots, and Aggregates

Identify any Contexts that are outside of your primary Bounded Context

Walk through and refine the Story Map



================================================================================
SLIDE 51
================================================================================

Subsystem Shaping



================================================================================
SLIDE 52
================================================================================

Kanban – Subsystem Shaping

Identify events crossing bounded context boundaries.

Define testable thin slices

Outline key domains and entities

Refine story map

Create thin-slices

Estimate story counts

Identify bounded contexts

EventStorming to define flow across contexts

Create bounded context map

Add stories to Jira

Add stories to confluence

Complete story acceptance criteria

Develop stories using TDD

Track flow

Refine entities and value objects

Define domain internals

Test all story acceptance criteria

Test thin-slice acceptance criteria

Perform regression test



================================================================================
SLIDE 53
================================================================================

Goal: Identify events crossing bounded context boundaries. Refine thin-slice with stories and add stories to Jira and Confluence.

Key Activities

Extend thin-slice story map with event storming to define flow across bounded contexts

Identify system-stories

Add stories to Jira

Add story details to Confluence

Key Practices

Domain-driven design

EventStorming

A Recap on Subsystem Shaping

Key Tools

Miro

Jira

Confluence

Key Participants

Tech Leads

Product Analysts



================================================================================
SLIDE 54
================================================================================

Having different work item types helps us align, plan and organize our work.

Work Item Hierarchy Explained



================================================================================
SLIDE 55
================================================================================

Determining Context BoundariesThrough EventStorming



================================================================================
SLIDE 56
================================================================================

Event Storming Structure

We can extend our story map with EventStorming to identify domain events, system  and identify external systems

Submit Customer Credit Application Details

Credit Application Submitted

Evaluate Credit Eligibility

Credit Application Approved

Send Denied Notification to Customer

Credit Application Denied

Send Approval Notification to Customer

Generate Credit Card Account Number

Etc.

A Command often represent user interactions.

A Reaction is something that needs to happen after something else happens.  Always described in the imperative.

An Event is something that creates a state change.  Always described in Past-tense

We can facilitate EventStorming by taking our story map and adding different commands, events, or reactions.



================================================================================
SLIDE 57
================================================================================

Let’s visualize a high-level credit card example which spans across a few boundaries

Credit Card Account

Credit Card

Command

Reaction

Event

Make CC Plan Available for all Customers

Sign Up Customer for Credit Card Plan

Credit Card Account Created

Mail CC & Activation Code to Customer

Use Credit Card

Credit Card Transaction Completed

New Credit Card Plan Created

Create New Credit Card Plan

Credit Card Plan

“Important events cause reactions elsewhere in the system, and it’s often important to understand why those reactions occurred”.



================================================================================
SLIDE 58
================================================================================

We can group events and stories to refine the exact scope of responsibility for each bounded contexts

Credit Card

Credit Card Account

Command

Reaction

Event

Credit Card Plan



================================================================================
SLIDE 59
================================================================================

System Story Exercise:

Refine the story map with an EventStorming timeline and add system stories.

Review the thin-slice story map on Miro.

Choose an Epic or set of stories as your frame of reference.

Add EventStorming concepts into the flow:

Commands

Domain Events

Reactions

Create a first cut of grouping or boundaries.



================================================================================
SLIDE 60
================================================================================

Defining a Bounded Context Map



================================================================================
SLIDE 61
================================================================================

Bounded Context

explicitly set boundaries in which the context of a model is applicable and explicitly managed to be uniform

Organizational:  a team, department, community, etc.

Implementation: code base, database schema, etc.

Bounded Context Map

marks the boundaries and relationships between different models and/or system contexts in a specific project, program, or organization

determines appropriate integration strategies

identifies where  a context may be shared across teams

may span an entire system, a portion of a system, or across several systems within the enterprise

A Bounded Dependency Map illustrates the relationship across our solution and the different teams, calling out how dependencies are managed on large scale programs

[IMAGE(S) FOR THIS SLIDE]
--------------------------------------------------------------------------------
  Image: slide_061_image_1.png
  Location: images/slide_061_image_1.png



================================================================================
SLIDE 62
================================================================================

We can use A  Bound Context Map to illustrate a modern, micro-services based solution

Credit Card Plans

CC Accounts

Credit Card

CC Billing

Payments

Credit Check

Event



================================================================================
SLIDE 63
================================================================================

0..*

1..*

1..2

Credit Card

Credit Card Account

Credit Card Plan



================================================================================
SLIDE 64
================================================================================

0..*

1..*

1..2

Credit Card

Credit Card Account

Credit Card Plan



================================================================================
SLIDE 65
================================================================================

CC Account Service

CC Account Repo

CC Plan Service

CC Plan Repo

Credit Card Service

Credit Card Repo

Properly defined bounded context enable agile teams to work autonomously while participating in a much larger ecosystem

Use Domain Driven Design to define the right boundaries for contexts that different teams can work on in a autonomous fashion

Account Team

CC Plan Team

Credit Card Team

[IMAGE(S) FOR THIS SLIDE]
--------------------------------------------------------------------------------
  Image: slide_065_image_1.png
  Location: images/slide_065_image_1.png



================================================================================
SLIDE 66
================================================================================

We need to call out mapping,  an integration mechanism, and a team engagement model for every dependency that exists across or bounded context map

Identify key domain constructs/objects that are relevant across more than one bounded context

Map out how the specific elements relate to each other

Identify the integration approach

Identify how the teams will collaborate across the bounded context

CRM System

Accounts System

Interests | Job

How will the two teams collaborate?

Travelling Team Members (Significant Change)

Members from multiple teams work as a single team

Service Provider(Small Change)

One team makes changes according to needs of other team

Enabler(No Change)

One team provides support to enable another team to use their code

How will we integrate  across the systems?

Events

Batch

Messaging

REST / API



================================================================================
SLIDE 67
================================================================================

We can also use a Bounded Context Map to Illustrate the Different Contexts Between Systems and the Teams that Support Them

[IMAGE(S) FOR THIS SLIDE]
--------------------------------------------------------------------------------
  Image: slide_067_image_1.png
  Location: images/slide_067_image_1.png



================================================================================
SLIDE 68
================================================================================

Exercise: Take 30 mins Build a Bounded context map

Zoom out from the thin slice

Explore bounded contexts that are outside of patient, drug, and prescription

Draw arrows to indicate which contexts would need to collaborate with another and why

Each team be ready to spend 10 minutes showing your results!



================================================================================
SLIDE 69
================================================================================

DDD During Story Exploration



================================================================================
SLIDE 70
================================================================================

Exercise: Take 30 mins - 1 hour

Align your Model and Map

Exercise: Take 30 mins – 1 hour

Discuss the integration points (pull in team members across boundaries)

This week

Populate & Document & Build in Jira and Confluence



================================================================================
SLIDE 71
================================================================================

A Brief Recap On Story Exploration



================================================================================
SLIDE 72
================================================================================

Goal: Perform enough planning for the next burst of value creation for a small cross functional team to collaborate on delivery

A Review on Story Exploration

Key Activities

The understanding of stories & solution have been refined for a tightly integrated increment of business value

A subset of the team have estimated the work and committed to delivering it

Acceptance criteria have been defined for the story

Key risks/unknowns/assumptions have been explored for the value increment

Agile Accelerators

Story Sketch

Relative Sizing and Estimation

Class Responsibility Cards

Domain Driven Design

Experimentation Sketch



================================================================================
SLIDE 73
================================================================================

Explore Stories in groups that are easy to describe, deliver, and test together

Two approaches to group stories together for exploration are commonly used by agile teams…..

Take all the stories from your next MVP that all belong to the same Feature within your story Map

Further thin slice your next MVP on your Story Map into Scenarios based on a particular assumption, decision, value, or risk that you want to test as an integrated group

Prove basic data model  > base pricing, ordinary charge items, 1 account per customer

Define Products

Define products

Define Charge Items

Add base price items

Add non standard price items

Define plans for product

Define non standard plans

Create Agreement for Product

Create profile for customer

Create profile for multi-account customer

Define Plans

Define multi product

Charge Items

Easier to manage dependencies and isolate work across team members

Provides earlier feedback to validate the system from an end-to-end perspective



================================================================================
SLIDE 74
================================================================================

Acceptance criteria

Once you have grouped stories together explore the key points you want to understand as a team before engineering starts

Define Products

Define products

Define Charge Items

Define multi product

Charge Items

When a user deletes a Product, Then the Product is archived

When a Product is saved in draft state Then changes Will Not Be propogated

A Product Must have a Minimum of one chargeable item

When A  User Chooses to Modify A Product, Then the User is presented with the option to add or remove

edit Items

When a Product is approved Then the Product will be available for charging

Unknown/Risks

Key Scenarios

How do we handle international products?

which destination system to integrate?

Valid product

Who can approve items?

Invalid product

International product

Other key points to cover in exploration session can include

UI / free drawing

Integration

Data elements

Business rules

Etc.

Big focus here!

Good behavioral acceptance criteria will often specify outcomes that result from user and system triggers following the form of When <trigger> then <outcome>

Good domain acceptance criteria will often describe the subjects and their rules, constraints, structure, responsibilities, interactions, and parameters for your business or technical domain concept

Can use the form <A Concept> <interacts with> <another Concept>



================================================================================
SLIDE 75
================================================================================

The number and size of stories often change as a result of exploration sessions

Define Products

Modify product

Modify charge item

Submit product change for approval

Approve submitted product

Associate Charge Items To Products

Acceptance criteria

When a user deletes a Product, Then the Product is archived

When a Product is saved in draft state Then changes Will Not Be propagated

A Product Must have a Minimum of one chargeable item

When A  User Chooses to Modify A Product, Then the User is presented with the option to add or remove

edit Items

When a Product is approved Then the Product will be available for charging

Approver is notified by email

[IMAGE(S) FOR THIS SLIDE]
--------------------------------------------------------------------------------
  Image: slide_075_image_1.png
  Location: images/slide_075_image_1.png



================================================================================
SLIDE 76
================================================================================

Acceptance Criteria



================================================================================
SLIDE 77
================================================================================

Capturing Domain Acceptance Criteria



================================================================================
SLIDE 78
================================================================================

Key Activities

Define a group of Stories are easy to describe, deliver, and test together.

Define behavioral acceptance criteria for the stories as a group

Increase your understanding by exploring the domain

The objective of story grooming is to a shared team understanding for the next burst of value creation

Define Products

Define Product Catalogue

Product Managers

Configure Plans for Products

Agree to Product Plan

Conducts Chargeable Activity

Customer

Calculate

Bill

Use  Product and Charge



================================================================================
SLIDE 79
================================================================================

Key Activities

Define a group of Stories are easy to describe, deliver, and test together.

Define behavioral acceptance criteria for the stories as a group

Increase your understanding by exploring the domain

The objective of story grooming is to a shared team understanding for the next burst of value creation

Define Products

Define Product Catalogue

Product Managers

Configure Plans for Products

Agree to Product Plan

Conducts Chargeable Activity

Customer

Calculate

Bill

Use  Product and Charge



================================================================================
SLIDE 80
================================================================================

The objective of story grooming is to a shared team understanding for the next burst of value creation

When a Customer signs up to use a Product

Then a Product Agreement is created

And  the Product is activated for that Customer

When the Product is activated for the Customer

Then associated Chargeable Activity for that Customer will flagged to be tracked

When a Customer conducts Chargeable Activity

Then that Chargeable Activity will be tracked

When a Billing Period is completed

Then a Customer Bill will be generated for all relevant Chargeable Activity

Good acceptance criteria will often specify outcomes that result from user and system triggers following the form of When <trigger> then <outcome>

Agree to Product Plan

Conducts Chargeable Activity

Customer

Calculate

Bill

Use  Product and Charge

Key Activities

Define a group of Stories are easy to describe, deliver, and test together.

Define behavioral acceptance criteria for the stories as a group

Increase your understanding by exploring the domain

Acceptance Criteria



================================================================================
SLIDE 81
================================================================================

The objective of story grooming is to a shared team understanding for the next burst of value creation

When a Customer signs up to use a Product

Then a Product Agreement is created

And  the Product is activated for that Customer

When the Product is activated for the Customer

Then associated Chargeable Activity for that Customer will flagged to be tracked

The Product Agreement lists the Terms and Conditions where the Customer can use a specific Product and be charged according to a Product Plan

Individual Pricing Items in the Product Plan specify the specific pricing for a Types Of  Chargeable Activity that the Customer may conduct

Associated Chargeable Activity is identified by referring to the Type Of Chargeable Activity priced through a Price Item in the Product Plan

Acceptance Criteria

Agree to Product Plan

Conducts Chargeable Activity

Customer

Calculate

Bill

Use  Product and Charge

Key Activities

Define a group of Stories are easy to describe, deliver, and test together.

Define behavioral acceptance criteria for the stories as a group

Increase your understanding by exploring the domain



================================================================================
SLIDE 82
================================================================================

The objective of story grooming is to a shared team understanding for the next burst of value creation

When a Customer conducts Chargeable Activity

Then that Chargeable Activity will be tracked

Associated Chargeable Activity is identified by referring to the Type Of Chargeable Activity priced through a Price Item in the Product Plan that is associated with a Customer through the Product Agreement

The Type Of Chargeable Activity, the Customer, and the Billing Period is tracked

Acceptance Criteria

Conducts Chargeable Activity

Agree to Product Plan

Customer

Use  Product and Charge

Calculate

Bill

Key Activities

Define a group of Stories are easy to describe, deliver, and test together.

Define behavioral acceptance criteria for the stories as a group

Increase your understanding by exploring the domain



================================================================================
SLIDE 83
================================================================================

The objective of story grooming is to a shared team understanding for the next burst of value creation

When a Billing Period is completed

Then a Customer Bill will be generated for all relevant Chargeable Activity

A Bill is calculated based on Chargeable Activity for a specific Customer within a Billing Period

The Chargeable Activity is found by looking up the Product Plan referred to by the Customer's  Product Agreement, and calculating a Charge for each Pricing Items in the Product plan

The volume of  Chargeable Activity for the  Pricing Item is collected for the Type Of  Chargeable Activity being priced  by the Price item

Each Price Item will calculate a Charge by running the Chargeable Activity through it’s Billing Calculation Method, creating A Bill Line Item

The total price of the Customer Bill will calculated from the total of the Bill Line Items

Acceptance Criteria

Conducts Chargeable Activity

Agree to Product Plan

Customer

Use  Product and Charge

Calculate

Bill

Key Activities

Define a group of Stories are easy to describe, deliver, and test together.

Define behavioral acceptance criteria for the stories as a group

Increase your understanding by exploring the domain

Good structural acceptance criteria use the form <A Concept> <interacts with> <another Concept>



================================================================================
SLIDE 84
================================================================================

Stories often get cluttered with information that applies to more than one story, epic, feature etc

Teams end up re-iterating the same concepts over and over

When concepts cross teams this repetition gets worse and worse…

The understanding of concepts often change over time, sometime because we learn, sometimes because we forget

Different stories can end up contradicting each other, and be inconsistent in the way ideas are expressed

This gets worse as we scale, especially when more than one team is working in the same domain

When everything is in stories, we observe adverse effects

[IMAGE(S) FOR THIS SLIDE]
--------------------------------------------------------------------------------
  Image: slide_084_image_1.jpg
  Location: images/slide_084_image_1.jpg



================================================================================
SLIDE 85
================================================================================

When grooming articulate story behavior in the domain

Conducts Chargeable Activity

Agree to Product Plan

Calculate

Bill

The Product Agreement lists the Terms and Conditions defining how the signing Customer can use a specific Product and be charged according to  a Product Plan

Individual Pricing Items in the Product Plan specify the specific pricing for a Types Of  Chargeable Activity that the Customer may conduct

The Type Of Chargeable Activity, the Customer, and the Billing Period is tracked for all Chargeable Activity

A Bill is calculated at the end of every Billing Period, calculated based on all  Chargeable Activity for each Customer

A Charge calculated a for each Pricing Items in the Product plan, by collecting all

The total Chargeable Activity for the  Pricing Item is collected by referring to Type Of  Chargeable Activity being priced  by the Price item

Each Price Item will calculate a Charge by running the Chargeable Activity through it’s Charge Calculation Method, creating A Bill Line Item

Signed by a Customer     Customer

Agrees to use a Product at a Price            Product Plan

Conducts Chargeable

Activity	             Charge Activity

Is Charged	             Product Agree.,

Billing Period

Of a Type	            Type of 	  	            Charge Activity

During a Bill Period        Billing Period

Is priced through

Numerous Plans	             Price Item

Prices ChargeActivity through              Price Items

Activate for Customer   Customer, 	            Price Items

Calculates a Charge         Billing Period,

Product Agree,

Type Of Charge

Activity

Made up of Line Items    Bill Line Items

Present a Total Charge

During a Billing Period    Billing Period

Based on a Price	              Price Item



================================================================================
SLIDE 86
================================================================================

The first step to establishing micro-services, understanding your bounded contexts

[IMAGE(S) FOR THIS SLIDE]
--------------------------------------------------------------------------------
  Image: slide_086_image_1.png
  Location: images/slide_086_image_1.png



================================================================================
SLIDE 87
================================================================================

Exercise:

Story Sketch all Stories within a Feature or Scenario

Explore the Domain using Class Responsibily Cards (or some other method!)



================================================================================
SLIDE 88
================================================================================

Capturing Domain Internal (Services, Events, Repositories)



================================================================================
SLIDE 89
================================================================================

DDD Provides a Means to Partition Business Logic According In The Model and the Code

Patient

Pick Up Method

Address

Entities

Have an identity that remains the same regardless of changes to specific data. Are the primary domain concepts we care about

We identify a Unique Patient In The System by their PHIN, and through a unique combination of Address, Name, and Phone

Value Objects

Are attributes, they do not have any inherent identity, and shared by many different Entities, considered Read Only

The parts of the system can we assume are immutable include Pick Up Methods and Addresses…

Clinical Information

Insurance

Aggregates

A grouping of closely associated objects that should be treated as a single unit for the purpose of data access and changes, defined in terms of roots that are directly accessible, and boundaries

We access all Patient Information directly through the Patient

Services

Gatekeeper to accessing business logic for a particular domain, services control/encapsulate business rules, business logic and business validation for a particular domain

The public operations for Patient that we want to expose to the rest of the system include Search, Merge, …

Patient Service

Repository

Represents the persistence layer required to search/access/ modify domain objects, Repositories are a simple and business specific interface for all operations on stored data

We can search for Patients by any combination of PHIN, Fname, Lname, Address, …

Patients

Events

The Conditions and state changes that happen within the Payments Domain that are made available for the rest of the system to consume. Most integrations across Contexts should occur asynchronously through Events

Events are raised whenever Patients change their Address, Insurance, Pickup Method…

Patient Created

Patient Merged

Bounded Context

Is a boundary explicitly set where the details of a subset of the domain is consistent and uniformly true. Consistency is expected to be true for the business domain language, domain model, and domain code, for a domain focused team.

The way we represent Patients and all of it’s internal will be consistent for every one working on the Payments Module

Each Domain Artifact Is Built Through Deep Understanding Of The Business Domain

Patient Bounded Context



================================================================================
SLIDE 90
================================================================================

1..*

0..*

Produces

Subscribes to

Extend your Domain Model by incorporating Services and Events for each Bounded Context

Credit Card

Credit Card Account

Credit Card Plan



================================================================================
SLIDE 91
================================================================================

1..*

0..*

Produces

Subscribes to

Extend your Domain Model by incorporating Services and Events for each Bounded Context

Credit Card

Credit Card Account

Credit Card Plan



================================================================================
SLIDE 92
================================================================================

Spec By Example



================================================================================
SLIDE 93
================================================================================

Build Spec In Language using Sequence of Stories

Scenario: Create a New “Teen Choice Plan” with Voice 500 Mins, 3000 SMS/MMS, 1 GB Data

Define Product Catalogue

Product Managers

Associate Chargeable Items to a Product

Create a Price Item for a Plan

Define Chargeable Items

Associate Price Item to a Plan

GIVEN: 	a Product Manager has Authorization to create Chargeable 	Items

WHEN: 	a Product Manager creates a valid Chargeable Item with an 	effective date

THEN: 	the Chargeable Item is submitted to the chargeable item list

AND: the Chargeable Item becomes available to be assigned 	to a

Product

WHEN: 	a Product Manager creates a Product using at least one

valid Chargeable Item

THEN: 	the Product is submitted to the product list

WHEN: 	a Product Manager creates a Price Item

AND: associates it to a Plan with an effective date

AND: Product Manager associates the Plan with a Product

THEN: 	the Plan is submitted to the plan list

[IMAGE(S) FOR THIS SLIDE]
--------------------------------------------------------------------------------
  Image: slide_093_image_1.png
  Location: images/slide_093_image_1.png



================================================================================
SLIDE 94
================================================================================

Now To Extend Spec in Lang. Into Spec By Example

Product Manager ID | Authorization Type

jsmith | Admin

Chargeable Item Code | Chargeable Item Desc. | Effective Date

9001 | Voice | 11/01/2017

9002 | SMS/MMS | 11/01/2017

9003 | Data | 11/01/2017

Scenario: Create a New “Teen Choice Plan” with Voice 500 Mins, 3000 SMS/MMS, 1 GB Data

GIVEN: 	a Product Manager has Authorization to create Chargeable Items

WHEN: 	a Product Manager creates a valid Chargeable Item with an effective date

THEN: 	the Chargeable Item is submitted to the chargeable item list

AND: the Chargeable Item becomes available to be assigned to a Product

[IMAGE(S) FOR THIS SLIDE]
--------------------------------------------------------------------------------
  Image: slide_094_image_1.png
  Location: images/slide_094_image_1.png



================================================================================
SLIDE 95
================================================================================

Now To Extend Spec in Lang. Into Spec By Example Cont.

Product Code | Product Description | Chargeable Item Code

01 | Mobile | 9001

01 | Mobile | 9002

01 | Mobile | 9003

Plan ID | Plan Description | Product Code | Chargeable Item Code | Price | Calculation Method | Effective Date

1 | Teen Choice | 01 | 9001 | $0.02 1-500
$0.10 500+ | Tier/Range | 12/01/2017

1 | Teen Choice | 01 | 9002 | $0.0033 1-3000
$0.05 3000+ | Tier/Range | 12/01/2017

1 | Teen Choice | 01 | 9003 | $0.0195 1-1024
$0.05 1024+ | Tier/Range | 12/01/2017

Scenario: Create a New “Teen Choice Plan” with Voice 500 Mins, 3000 SMS/MMS, 1 GB Data

WHEN: 	a Product Manager creates a Product using at least one valid Chargeable Item

THEN: 	the Product is submitted to the product list

WHEN: 	a Product Manager creates a Price Item

AND: associates it to a Plan with an effective date

AND: Product Manager associates the Plan with a Product

THEN: 	the Plan is submitted to the plan list

[IMAGE(S) FOR THIS SLIDE]
--------------------------------------------------------------------------------
  Image: slide_095_image_1.png
  Location: images/slide_095_image_1.png



================================================================================
SLIDE 96
================================================================================

Not Used’;l,l,k



================================================================================
SLIDE 97
================================================================================

DDD During Story Delivery



================================================================================
SLIDE 98
================================================================================

Microservice Explosion!

Business logic sprawl!

When the boundaries Microservices are not properly defined the result can be a complicated mess

[IMAGE(S) FOR THIS SLIDE]
--------------------------------------------------------------------------------
  Image: slide_098_image_1.jpg
  Location: images/slide_098_image_1.jpg



================================================================================
SLIDE 99
================================================================================

Microservices allow technology solutions to scale without sacrificing adaptability to change

Business Logic

Persistence Access

Persistence

Container

Front End

Back End

Devops

Team

Componentization via Services

Organized around Business Capabilities

Choreographed Not Orchestrated

Light weight messaging

Decentralization

Automation

Built For Failure

Evolutionary Design

Key Principles

Small, focused on the logic of a single domain

Light weight in terms of tech stack and messaging protocols

Cloud native deployment, Continuous Deployment and Monitoring

Microservices done well increase scalability without sacrificing agility

[IMAGE(S) FOR THIS SLIDE]
--------------------------------------------------------------------------------
  Image: slide_099_group_image_1.png
  Location: images/slide_099_group_image_1.png
  Image: slide_099_image_1.png
  Location: images/slide_099_image_1.png



================================================================================
SLIDE 100
================================================================================

Connect the model to architecture by “injecting” common functionality through inheritance, collect common behavior into a set of requirements that influence the choice of technology, patterns and/or APIs

[IMAGE(S) FOR THIS SLIDE]
--------------------------------------------------------------------------------
  Image: slide_100_image_1.jpg
  Location: images/slide_100_image_1.jpg



================================================================================
SLIDE 101
================================================================================

Domain Driven Design and Team Structure



================================================================================
SLIDE 102
================================================================================

Your Org and Software Are Really One System

The Peril Of Ignoring Conway’s Law

Introducing The Inverse Conway Manuever



================================================================================
SLIDE 103
================================================================================

The Perils Of Focusing On Software Internals

Your Org and Software Are Really One System

The Peril Of Ignoring Conway’s Law

Introducing The Inverse Conway Manuever



================================================================================
SLIDE 104
================================================================================

Remember Domain Driven Design

Organize Domain Aggregates

Bounded Contexts

[IMAGE(S) FOR THIS SLIDE]
--------------------------------------------------------------------------------
  Image: slide_104_image_1.png
  Location: images/slide_104_image_1.png



================================================================================
SLIDE 105
================================================================================

Identifying Domain Aggregates and Context Boundaries

Regulatory and Compliance

Transaction Rates

Market Actors

Domain Life Cycle State



================================================================================
SLIDE 106
================================================================================

Identifying Domain Aggregates and Context Boundaries

Limiting Domain Complexity Per Team

The Modern World Of Micro-Services

[IMAGE(S) FOR THIS SLIDE]
--------------------------------------------------------------------------------
  Image: slide_106_image_1.png
  Location: images/slide_106_image_1.png



================================================================================
SLIDE 107
================================================================================

Organize Around Technology Instead

[IMAGE(S) FOR THIS SLIDE]
--------------------------------------------------------------------------------
  Image: slide_107_image_1.png
  Location: images/slide_107_image_1.png



================================================================================
SLIDE 108
================================================================================

Ensuring Model Consistency



================================================================================
SLIDE 109
================================================================================

Multiple models

coexist on big projects

Is applicable in a context; a certain part of the code, or the work of a particular team

Improper sharing of models results in confusion

Duplication: multiple model updates and synchronization increase complexity and inefficiency

Misalignment: the same concept or codebase is means something different to multiple parties while assuming think they are talking about the same thing

When multiple teams work on large systems, confusion and rework is the norm

[IMAGE(S) FOR THIS SLIDE]
--------------------------------------------------------------------------------
  Image: slide_109_group_image_1.png
  Location: images/slide_109_group_image_1.png
  Image: slide_109_image_1.png
  Location: images/slide_109_image_1.png



================================================================================
SLIDE 110
================================================================================

A range of Model Sharing Patterns can be used to establish how individuals Domain Boundaries can be integrated between agile teams

Shared Kernel: Portions of two separate systems require tight integration. Designate some subset of the domain model,  code, database, etc that the two teams agree to share. No changes to model subset is made without participation from both teams

Customer/ Supplier teams:  One subsystem feeds another and all the dependencies go one way.  Establish a clear customer/supplier relationship between the two teams.  Make the dependent team play the customer role, providing requirements and allocating budget to the supplier team. Jointly develop automated acceptance tests to validate team interfaces. Both teams use these tests as part of their own continuous integration.

customer

supplier

Conformist:  Two teams are in different companies or very far apart in the management hierarchy. Force the team with the dependencies to adhere to the model of the team upon which they depend.  This may not yield the ideal model for the application but greatly simplifies integration. Often appropriate when delivering an enterprise package solution (e.g. PeopleSoft, SAP) that requires a slight or moderate customization/configuration.

Anticorruption Layer:  A new system is being built has a large interface with another system with an established model. Prevent the new model from being modified ad-hoc to resemble the other system’s model by creating an isolation layer.  The isolation layer provides clients with functionality in terms of their own domain model.  The layer talks to the other system through its existing interface, requiring little or no modification to the other system.  Internally, the layer translates in both directions as necessary between the two models.



================================================================================
SLIDE 111
================================================================================

A range of Model Sharing Patterns can be used to establish how individuals Model Boundaries can be integrated across an enterprise

Open host services: A subsystem has to be integrated with many others. Define a common  protocol that gives access as a set of services.  Open the protocol to all teams who need access can use it.  Enhance and expand the protocol to handle new requirements as necessary.

Published language: Direct translation to and from the existing domain models may not be a good solution.  Those models may be overly complex or poorly factored.  In this case, use a well documented shared language that can express the necessary domain information as a common medium of communication, translating as necessary into and out of that language.

Separate ways: sometimes the value of integration is outweighed by the cost to do so. In this case two teams may approach similar concepts and functionality in entirely different weights and agreed to go on their own separate path. Agreeing to disagree

[IMAGE(S) FOR THIS SLIDE]
--------------------------------------------------------------------------------
  Image: slide_111_image_1.png
  Location: images/slide_111_image_1.png



================================================================================
SLIDE 112
================================================================================

Use a deliberate strategy to ensure that models stay consistent within and across different team and system boundaries

Keep elements in a model boundary consistent

Models will fragment when worked on by multiple parties in parallel

Continuous Integration of both concepts and implementation is required to stay in synch

High level of rigour; only required within an individual bounded countext

Synchronize across boundaries according to the nature of the dependency

Establishing clear boundaries for each context in play

Identifying relationships across the different context based on dependencies

Define an integration strategy to govern how different team will resolve and synchronize each cross context dependency

[IMAGE(S) FOR THIS SLIDE]
--------------------------------------------------------------------------------
  Image: slide_112_group_image_1.png
  Location: images/slide_112_group_image_1.png


