---
description: Domain-Driven Design structure analysis principles for extracting domain models
globs: ["**/*.md", "**/*.txt", "**/*.mdc", "**/*.js", "**/*.ts", "**/*.py", "**/*.mjs"]
alwaysApply: false
---
**When** analyzing code, text, or diagrams to extract domain models,
**then** follow these principles to create clear, business logic-centered domain representations.

Domain structure analysis identifies core business concepts, their relationships, and organizing principles. The goal is to map from the user's mental model, not the code's structure.

**Executing Commands:**
* `\ddd-analyze` — Analyze file/code/text to extract domain structure
* `\ddd-validate` — Validate domain structure against DDD principles

---

## OVERVIEW: Domain Structure Format

**Purpose:**
Extract domain structures from any source (code, text, diagrams, documentation) and represent them hierarchically with clear relationships.

**Output Format:**
Text-based hierarchical domain map with tabs for nesting levels.

**Key Elements:**
1. **Functional Purpose** - What this accomplishes for users
2. **Domains** - Major functional capabilities (ordered domain-first)
3. **Concepts** - Entities, services, values within each domain
4. **Relationships** - How concepts relate (embedded in each concept)
5. **Infrastructure** - Technical systems (separate, at end)

**Example Structure:**
```
FUNCTIONAL PURPOSE: <what this accomplishes>

DOMAIN 1
	<what this domain does>
	
	RELATIONSHIPS:
		USES: Infrastructure Component Y
	
	Concept A
		<what this concept does>
		<properties it has>
		
		RELATIONSHIPS:
			USES: Concept B
			CONTAINS: Concept C
		
		Concept C (nested under A)
			<nested concept details>
	
	Concept B
		<foundation concept>

DOMAIN 2
	<another domain>

SYSTEM INFRASTRUCTURE
	<technical systems>
	
	RELATIONSHIPS:
		SERVES: Domain 1, Domain 2
```

**Validation Checklist:**
- [ ] Functional purpose stated at top
- [ ] All verbs are outcome-focused, not communication verbs
- [ ] System support integrated under domain concepts
- [ ] Concepts ordered by user mental model (foundation → features)
- [ ] Domain concepts before system infrastructure
- [ ] Related concepts maximally integrated
- [ ] Relationships embedded in each concept

---

## 1. Use Outcome Verbs, Not Communication Verbs

**Principle:**
Each verb should describe the actual outcome or artifact being created, not the act of communicating/presenting information. If you can ask 'showing WHAT?' or 'displaying WHAT?', the verb is too generic—use what comes after instead.

**Do:**
* Use verbs that describe artifacts/outcomes: "Animation", "Feedback", "Indicators", "Configuration"
* Name concepts by what they ARE or CREATE: "Power Activation Animation", "Combat Outcome Feedback"
* Focus on tangible results: "Hit Indicators", "Save Result Feedback"
* Use domain-specific action verbs: "animates", "triggers", "composes", "orchestrates"

**Don't:**
* Use generic communication verbs: "showing", "displaying", "visualizing", "presenting"
* Use vague enablement verbs: "providing", "enabling", "allowing"
* Name concepts by their mechanism: "Visualizing Power Activation", "Showing Combat Results"
* Focus on presentation: "Display System", "Show Component"

**Examples from Actual Domain Analysis:**

DON'T - Communication Verbs (from initial mistakes):
* ❌ "VISUALIZING POWER ACTIVATION" 
  - "Visualizing" is about presenting information, not the outcome
  - Violates §1: communication verb instead of outcome
* ❌ "Showing Attack Results"
  - "Showing" describes presentation mechanism
  - Violates §1: what's being shown is what matters
* ❌ "Displays what happened when attacks are made"
  - "Displays" is communication mechanism
  - Violates §1: focus on the feedback itself
* ❌ "Shows fire effects for fire powers"
  - "Shows" is presentation, not creation
  - Violates §1: the effects are what matter
* ❌ "Provides power characteristics"
  - "Provides" is vague enablement
  - Violates §1: characteristics exist, no need to say "provides"
* ❌ "Enables users to configure"
  - "Enables" is about capability, not the artifact
  - Violates §1: configuration is the outcome

DO - Outcome/Artifact Verbs (after corrections):
* ✅ "POWER ACTIVATION ANIMATION"
  - Names the artifact created (animation)
  - Animation IS the functional goal
* ✅ "Attack Result Indicators"
  - Names the artifact (indicators)
  - Indicators ARE the outcome
* ✅ "Attack outcome feedback"
  - Names what exists (feedback about outcomes)
  - Feedback IS what's created
* ✅ "Fire-themed animation for fire powers"
  - Names the themed animation artifact
  - Animation with theme IS the result
* ✅ "Power characteristics"
  - Direct noun - the data itself
  - Characteristics exist as domain concept
* ✅ "Animation customization"
  - Customization IS the capability provided
  - Direct naming of the outcome
* ✅ "Animates power activation" (verb OK when animation IS the action)
  - "Animates" describes the core action
  - Animation is the domain purpose
* ✅ "Triggers combat feedback" (verb OK when triggering IS the action)
  - "Triggers" is the actual operation
  - Triggering is the mechanism being described

**Test:**
Can you replace 'X-ing' with 'X' and still have a meaningful goal?
* 'Animating power' → 'Animation of power' ✅ (animation IS the goal)
* 'Showing results' → 'Show of results' ❌ (showing isn't the goal, feedback is)
* 'Visualizing activation' → 'Visualization of activation' ❌ (visualization is mechanism, animation is goal)
* 'Providing characteristics' → 'Provision of characteristics' ❌ (just say "characteristics")

---

## 2. Integrate System Support Into Domain Concepts

**Principle:**
When you see 'SYSTEM SUPPORT FOR X' or other system type sections that contain lots of references to other domain sections, ask: does this implement the exact same functional capability as section X, just showing technical details? If yes, nest and integrate the system support UNDER the domain concept it implements, not as a separate section. Only keep system support separate if it enables multiple different domain capabilities or represents a genuinely different concern from the user's perspective.

**Do:**
* Nest technical implementation under the domain concept it serves
* Integrate "how" under "what" when they serve the same functional goal
* Keep implementation details close to the feature they implement
* Group by functional capability, not code organization

**Don't:**
* Separate domain concepts from their implementations into parallel sections
* Create "SYSTEM SUPPORT" sections that duplicate domain structure
* Organize by code boundaries (services, models, controllers)
* Split concepts users see as one thing into multiple sections

**Examples from Actual Domain Analysis:**

DON'T - Separated System Support (from initial mistakes):
* ❌ BEFORE (violated §2):
```
Matching Animation to Power Characteristics
  Matching to Descriptor
    Fire-themed animation for fire powers
    Ice-themed animation for ice powers
  Matching to Effect Type
    Damage animation for damage effects
  Matching to Range
    Melee animation for close-range powers
  Matching to Area
    Cone-shaped animation for cone areas

SYSTEM SUPPORT FOR POWER ANIMATION
  Technical implementation
  
  Power Item (PowerItem class)
    Power characteristics FOR animation matching
    Descriptor, effect, range, area storage
    Descriptor name generation for animation lookup
  
  Animation Resolution
    Finds animation sources FOR powers
    Checks attached macros (highest priority)
    Searches name-matched macros
    Queries AutoRec entries
```
  - Violates §2: "SYSTEM SUPPORT FOR POWER ANIMATION" duplicates domain structure
  - Violates §2: PowerItem and Animation Resolution separated from Matching (same goal)
  - Violates §3: PowerItem hidden under "Technical Implementation" (users need it FIRST)

DO - Integrated Implementation (after corrections):
* ✅ AFTER (follows §2, §3):
```
Power Item (PowerItem class)
  Wrapper for power providing characteristics needed for animation
  Stores descriptor (fire, ice, electricity, mental, physical, etc.)
  Stores effect type (damage, affliction, movement, defensive, control)
  Stores range (melee, ranged, personal, perception)
  Stores area shape (cone, line, burst)
  Generates descriptor names for animation lookup

Animation Resolution
  Finds appropriate animation for power
  Checks attached macros (item-flagged, highest priority)
  Searches name-matched macros (by descriptor name)
  Queries AutoRec entries (automated recognition)
  Generates descriptor-based animation (fallback, lowest priority)

Matching Animation to Power Characteristics
  Uses Power Item characteristics to select appropriate visuals
  
  Descriptor Matching
    Fire descriptor → Fire-themed animation
    Ice descriptor → Ice-themed animation
  
  Effect Type Matching
    Damage effect → Damage animation
    Affliction effect → Affliction animation
```
  - Follows §2: No separate "SYSTEM SUPPORT" section
  - Follows §3: PowerItem comes FIRST (foundation object)
  - Follows §3: Animation Resolution before Matching (finds before matches)
  - Follows §2: Everything integrated by functional goal

DON'T - Another Example (from initial mistakes):
* ❌ BEFORE (violated §2):
```
Attack Result Indicators
  Communicates what happened when attacks are made
  
  Hit Indicators
    "Hit" text beside target
  Miss Indicators
    "Miss" text beside target

SYSTEM SUPPORT FOR COMBAT FEEDBACK
  Technical implementation
  
  Text Animation System
    Animates floating text beside targets
    Colors by alliance and perspective
```
  - Violates §2: Text Animation System separated from indicators it implements
  - User sees these as one thing: "text indicators"

DO - Integrated (after corrections):
* ✅ AFTER (follows §2):
```
Text Animation System
  Creates floating text beside targets for all indicators
  Colors by alliance and perspective
  Applies fade and movement effects

Attack Result Indicators
  Uses Text Animation System to communicate attack outcomes
  
  Hit Indicators
    "Hit" text beside target
    Green text for ally hits, red for enemy hits
  
  Miss Indicators
    "Miss" text beside target
    Green text for ally misses, red for enemy misses
```
  - Follows §2: Text Animation System integrated (foundation comes first)
  - Follows §3: System that creates indicators comes before indicators
  - Clear relationship: "Uses Text Animation System"

---

## 3. Order by User Mental Model, Not Code Structure

**Principle:**
Order concepts by user's mental model: what do they encounter first and what builds on what? If something labeled 'Technical Implementation' contains the core objects users interact with, ensure it's a primary domain concept that other features build upon. Ask: would a user need to understand this concept BEFORE understanding the features that use it?

**Do:**
* Order concepts by user encounter sequence
* Put foundational objects BEFORE features that use them
* Start with core domain objects (PowerItem, User, Vehicle)
* Follow with operations on those objects
* End with supporting infrastructure
* Ask: "What builds on what?" from user perspective

**Don't:**
* Order by code structure (models, services, controllers)
* Hide core objects in "Technical Implementation" sections
* Start with features before introducing the objects they operate on
* Follow code dependency graphs instead of user understanding flow

**Examples from Actual Domain Analysis:**

DON'T - Code Structure Ordering (from initial mistakes):
* ❌ BEFORE (violated §3):
```
Matching Animation to Power Characteristics
  Selects appropriate visuals based on power properties
  
  Matching to Descriptor
    Fire-themed animation for fire powers
    Ice-themed animation for ice powers
  
  Matching to Effect Type
    Damage animation for damage effects
  
  Matching to Range
    Melee animation for close-range powers
  
  Technical Implementation
    Power Item (PowerItem class)
      Power characteristics FOR animation matching
      Stores descriptor, effect, range, area
    
    Animation Resolution
      Finds animation sources
```
  - Violates §3: Features (Matching) come before objects (PowerItem)
  - Violates §3: PowerItem hidden in "Technical Implementation"
  - User question: "How do I match?" → needs PowerItem first!
  - Code structure driven: matching logic comes before data

DO - User Mental Model Ordering (after corrections):
* ✅ AFTER (follows §3):
```
Power Item (PowerItem class)
  Wrapper for power providing characteristics needed for animation
  Stores descriptor (fire, ice, electricity, mental, physical, etc.)
  Stores effect type (damage, affliction, movement, defensive, control)
  Stores range (melee, ranged, personal, perception)
  Stores area shape (cone, line, burst)
  Generates descriptor names for animation lookup

Animation Resolution
  Finds appropriate animation for power
  Checks attached macros (item-flagged, highest priority)
  Searches name-matched macros (by descriptor name)
  Queries AutoRec entries (automated recognition)
  Generates descriptor-based animation (fallback, lowest priority)

Matching Animation to Power Characteristics
  Uses Power Item characteristics to select appropriate visuals
  
  Descriptor Matching
    Fire descriptor → Fire-themed animation
    Ice descriptor → Ice-themed animation
  
  Effect Type Matching
    Damage effect → Damage animation
```
  - Follows §3: PowerItem FIRST (user encounters this object)
  - Follows §3: Animation Resolution second (finds animation using PowerItem)
  - Follows §3: Matching third (applies resolution results)
  - User mental flow: "I have PowerItem → find animation → match characteristics → select visuals"

DON'T - Another Example (from initial mistakes):
* ❌ BEFORE (violated §3):
```
Animation Phases for Power Use
  Complete power activation sequence
  
  Cast Phase
    Power gathering animation
  Projection Phase
    Power traveling to target
  Area Phase
    Area of effect spreading
  Impact Phase
    Power hitting target

Technical Implementation
  Sequence Composition
    Assembles animation phases
    Orchestrates cast → projection → area → impact
```
  - Violates §3: Shows phases before explaining how they're assembled
  - User question: "How do phases work?" → needs Sequence Composition first!

DO - User Mental Model (after corrections):
* ✅ AFTER (follows §3):
```
Sequence Composition
  Assembles complete animation from matched characteristics
  Orchestrates phases: cast → projection → area → impact
  Integrates PowerItem characteristics
  Applies descriptor-specific visual themes
  
  Descriptor Sequence (DescriptorSequence class)
    Orchestrates complete animation for PowerItem
    Composes all phases into unified sequence

Animation Phases
  Complete power activation sequence executed
  
  Cast Phase
    Power gathering before release
    Cast Sequence (CastSequence class)
      Implements cast phase
  
  Projection Phase
    Power traveling to target
    Projection Sequence (ProjectionSequence class)
      Implements projection phase
```
  - Follows §3: Composition comes FIRST (how things work)
  - Follows §3: Individual phases second (what gets composed)
  - User understands: "Sequences compose phases → here are the phases"

---

## 4. Organize by Domain First, System Support Second

**Principle:**
Organize by what the user understands (domain concepts) not by how the code is structured (system layers). Favor domain-specific concepts over system-level concepts. In a vehicle domain: cars, passengers, bikes, acceleration, direction come BEFORE events, rendering, or validating.

**Do:**
* Lead with domain-specific concepts (Powers, Combat, Vehicles, Users)
* Name sections by business capabilities: "Power Activation", "Payment Processing"
* Group related domain concepts together
* Put system infrastructure at the end
* Frame purpose from functional perspective: "Make powers feel distinct"

**Don't:**
* Lead with system concepts (Events, UI, Services, Data Layer)
* Name sections by technical layers: "Presentation Layer", "Business Logic"
* Mix domain and system concepts at same level
* Frame purpose from technical perspective: "Render visual effects"

**Examples from Actual Domain Analysis:**

DON'T - System-First Organization (from initial mistakes):
* ❌ BEFORE (violated §4):
```
SYSTEM INTEGRATION LAYER
  Foundry VTT integration and lifecycle management
  
  Configuration Management
    Module settings and preferences
  
  Event System
    Foundry hook handlers
    
    Lifecycle Events
      System initialization
      UI rendering
    
    Game Events
      Power activation
      Combat outcomes
      Movement detection

DOMAIN MODEL
  Core business objects and domain concepts
  
  Power Representation
    MM3E power system modeling
    PowerItem, Effects, Range, Area
  
  Combat Model
    Combat mechanics representation
    Attacks, Defenses, Conditions
```
  - Violates §4: Leads with system layer (integration, events)
  - Violates §4: Domain concepts hidden under "DOMAIN MODEL"
  - User must wade through system infrastructure to reach Powers and Combat
  - Technical framing: "System Integration Layer"

DO - Domain-First Organization (after corrections):
* ✅ AFTER (follows §4):
```
POWER ACTIVATION ANIMATION
  Animated visual effects when powers are used
  
  Power Item (PowerItem class)
    Wrapper for power providing characteristics
    Stores descriptor, effect, range, area
  
  Animation Resolution
    Finds appropriate animation for power
  
  Matching Animation to Power Characteristics
    Uses Power Item characteristics

COMBAT OUTCOME FEEDBACK
  Visual feedback when combat events occur
  
  Combat Data Extraction
    Extracts combat results FROM chat messages
  
  Attack Result Indicators
    Hit Indicators, Miss Indicators, Critical Hit Celebration

ANIMATION CUSTOMIZATION
  Users configure power animations
  
  Sequence Runner Editor
    Main animation configuration tool

SYSTEM INFRASTRUCTURE
  Technical systems enabling all domains
  
  Foundry VTT Integration
    Game platform integration
    Configuration Management
    Event Detection
```
  - Follows §4: Domains first (POWER, COMBAT, CUSTOMIZATION)
  - Follows §4: Infrastructure last (SYSTEM INFRASTRUCTURE)
  - User immediately sees Powers, Combat, Customization
  - Business framing: "Power Activation Animation"

DON'T - Another Example (comparing initial vs final):
* ❌ INITIAL STRUCTURE (violated §4):
```
1. SYSTEM INTEGRATION LAYER
2. DOMAIN MODEL  
3. ANIMATION SYSTEM
4. USER INTERFACE LAYER
5. SUPPORT SERVICES
```
  - Violates §4: System concepts (Integration, UI, Services) mixed with domain
  - Technical layer names dominate

* ✅ FINAL STRUCTURE (follows §4):
```
1. POWER ACTIVATION ANIMATION
2. COMBAT OUTCOME FEEDBACK
3. ANIMATION CUSTOMIZATION
4. SYSTEM INFRASTRUCTURE
```
  - Follows §4: Domain capabilities first (what users care about)
  - Infrastructure clearly separated and last
  - Business-focused names

---

## 5. Refine Scope to Functional Accomplishment

**Principle:**
Refine scope of the domain to what is actually being accomplished from a functional perspective. If examining a module about vehicles that interacts with a map to display position and facing of cars, frame the domain as "updating cars so they can be rendered on the map", or inversely "display position of cars every time their position and rotation change".

**Do:**
* Focus on functional outcomes, not mechanisms
* Frame domains by what they accomplish for users
* Ask: "What does this enable the user to do or understand?"
* State the transformation or capability provided
* Be specific about the functional benefit

**Don't:**
* Frame domains by their technical implementation
* Focus on "how" before "what"
* Use generic system capabilities as domain names
* Describe mechanisms instead of outcomes

**Examples from Actual Domain Analysis:**

DON'T - Mechanism/Technical Focus (from initial mistakes):
* ❌ INITIAL PURPOSE (violated §5):
  - "Visualize superhero powers and combat through animated effects"
  - Violates §5: "Visualize" is mechanism (how), not outcome (what)
  - Violates §1: Also uses communication verb
  - Technical framing: focuses on "animated effects" mechanism

* ✅ FINAL PURPOSE (follows §5):
  - "Make superhero powers feel distinct and combat outcomes immediately clear"
  - Follows §5: "Make powers feel distinct" = functional outcome for users
  - Follows §5: "Combat outcomes clear" = what users gain
  - Business framing: focuses on user experience improvement

DON'T - Module Names (from initial mistakes):
* ❌ BEFORE (violated §5):
  - "ANIMATION SYSTEM"
  - Violates §5: "System" is technical component name
  - Doesn't say what it accomplishes
  - Could be any kind of animation system

* ✅ AFTER (follows §5):
  - "POWER ACTIVATION ANIMATION"
  - Follows §5: Specifies what's animated (power activation)
  - Clear functional scope: animating power activations
  - User knows exactly what this does

DON'T - Another Example (from initial mistakes):
* ❌ BEFORE (violated §5):
  - "COMBAT DOMAIN - Combat mechanics and outcomes"
  - Violates §5: "mechanics" is technical/implementation focus
  - Doesn't say what users get from this

* ✅ AFTER (follows §5):
  - "COMBAT OUTCOME FEEDBACK - Visual feedback when combat events occur"
  - Follows §5: "Feedback" is what users receive
  - Clear functional goal: inform users of combat outcomes
  - User-benefit focused

DON'T - Description Examples (from initial mistakes):
* ❌ "Visual representations of powers and combat"
  - Violates §5: "representations" is mechanism language
  - Focuses on how (visual) not what (distinct powers)

* ✅ "Animated visual effects when powers are used"
  - Follows §5: "when powers are used" = functional context
  - Specifies the triggering event and outcome

* ❌ "Provides visual editing and configuration tools"
  - Violates §5: "Provides tools" is mechanism
  - Doesn't say what user accomplishes

* ✅ "Users configure power animations"
  - Follows §5: States what users do/accomplish
  - Direct functional capability

---

## 6. Maximize Integration of Related Concepts

**Principle:**
Related concepts that serve the same functional goal should be maximally integrated, not artificially separated by code boundaries. If two concepts always work together from the user's perspective, they should be presented together.

**Do:**
* Group concepts that the user sees as one capability
* Nest implementation details under the feature they serve
* Keep related data and operations together
* Eliminate artificial boundaries based on code organization

**Don't:**
* Separate related concepts into different major sections
* Split based on code layers (data, business, presentation)
* Duplicate related concepts across multiple sections
* Create gaps that break the user's mental model

**Examples from Actual Domain Analysis:**

DON'T - Artificial Separation (from initial mistakes):
* ❌ BEFORE (violated §6):
```
POWERS DOMAIN
  Superhero powers and their characteristics
  
  Descriptors
    Defines power visual/thematic nature
    Fire, ice, electricity, mental, physical, cosmic, magic, etc.
  
  Effects
    Defines what power does mechanically
    
    Offensive Effects
      Damage, Affliction, Weaken, Mental Blast, Strike
    
    Defensive Effects
      Protection, Force Field, Deflection, Immunity
  
  Range
    Defines power reach
    Melee, ranged, personal, perception
  
  Area
    Defines power spread
    Cone, line, burst

---

ANIMATION DOMAIN
  Visual representations of powers and combat
  
  Cast Animation
    Visual buildup before power activates
  
  Projection Animation
    Visual delivery of power to target
```
  - Violates §6: Powers and Animation separated (user sees them together)
  - Violates §6: "ANIMATION DOMAIN" duplicates power structure
  - Violates §4: Domain boundaries based on code (powers vs animations)
  - User question: "What animation does a fire power have?" → must look in two places

DO - Integrated by Functional Capability (after corrections):
* ✅ AFTER (follows §6):
```
POWER ACTIVATION ANIMATION
  Animated visual effects when powers are used
  
  Power Item (PowerItem class)
    Wrapper for power providing characteristics needed for animation
    Stores descriptor (fire, ice, electricity, mental, physical, etc.)
    Stores effect type (damage, affliction, movement, defensive, control)
    Stores range (melee, ranged, personal, perception)
    Stores area shape (cone, line, burst)
  
  Animation Resolution
    Finds appropriate animation for power
  
  Matching Animation to Power Characteristics
    Uses Power Item characteristics to select appropriate visuals
    
    Descriptor Matching
      Fire descriptor → Fire-themed animation
      Ice descriptor → Ice-themed animation
    
    Effect Type Matching
      Damage effect → Damage animation
```
  - Follows §6: Power characteristics integrated with animation matching
  - Follows §6: User sees complete picture in one place
  - Follows §2: Also integration principle (system support under domain)
  - User answer: "Fire powers use fire-themed animation" - all in one section

DON'T - Separated Implementation (from initial mistakes):
* ❌ BEFORE (violated §6):
```
USER INTERFACE LAYER
  Provides visual editing and configuration tools
  
  Animation Configuration Editor
    Enables animation customization
    
    Sequence Runner Editor (SequenceRunnerEditor class)
      Main editor application
      Dialog construction and layout
      
      Descriptor Sequence View (DescriptorSequenceView)
        Sequence configuration
      
      Sequencer Script View (SequencerScriptView)
        Script configuration

---

Saving Custom Animations
  Animation configuration saved to power
  Executable script generation
  Storage as macro or power flag
  
  Technical Implementation
    Script Generation
      
      Sequencer Script (SequencerScript class)
        Executable script generation
```
  - Violates §6: Editor and Script Generation separated
  - User sees them as one workflow: edit → save → generate
  - Artificial boundary: UI vs saving

DO - Integrated Workflow (after corrections):
* ✅ AFTER (follows §6):
```
ANIMATION CUSTOMIZATION
  Users configure power animations
  
  Sequence Runner Editor (SequenceRunnerEditor class)
    Main animation configuration tool
    Edit button on item sheets opens editor
    
    Descriptor Sequence View (DescriptorSequenceView)
      Configures animation sequences
      Descriptor dropdowns for selection
      Real-time preview of selections
    
    Sequencer Script View (SequencerScriptView)
      Configures and previews executable script
      Generated code preview
  
  Script Generation
    Creates executable code from configuration
    
    Sequencer Script (SequencerScript class)
      Generates executable animation script
      Applies range-based logic
  
  Saving Custom Animations
    Saves animation configuration to power
    Stores as macro or power flag
```
  - Follows §6: Complete workflow in one section
  - Follows §3: Also follows ordering (edit → generate → save)
  - User sees: "I edit → script generates → I save" - integrated flow

DON'T - Code Layer Boundaries (from initial mistakes):
* ❌ Separated by layers:
```
DATA LAYER
  PowerItem (stores power data)

BUSINESS LOGIC LAYER  
  Animation Resolution (finds animation)
  Matching Animation (matches characteristics)

PRESENTATION LAYER
  Animation display
```
  - Violates §6: User sees as one capability, not three layers

* ✅ Integrated by capability:
```
POWER ACTIVATION ANIMATION
  PowerItem (data)
  Animation Resolution (logic)
  Matching Animation (uses both)
  Animation Phases (presentation)
```
  - Follows §6: All aspects of "power animation" together

---

## 7. Domain Concepts Are Nouns, Behaviors Are Verbs

**Principle:**
Domain concepts should be named as nouns (things that exist), and their operations should be described as behaviors (verbs). If a verb feels important enough to be its own concept, it must have state and logic of its own - then it becomes a noun (e.g., "Animation" not "Animating", "Resolution" not "Resolving").

**Do:**
* Name domain concepts as nouns: "Animation", "Power Item", "Sequence", "Configuration"
* Describe what the concept IS first, then what it DOES
* Use verbs to describe behaviors on concepts: "Resolves animation", "Executes when triggered"
* If a verb has its own state/logic, make it a noun concept
* Mark behaviors with "(behavior)" suffix for clarity

**Don't:**
* Name domain concepts as verbs or gerunds: "Animation Resolution", "Animation Execution"
* Use "-ing" forms for concept names: "Animating", "Resolving", "Processing"
* Create separate concepts for "Doing X" vs "X" - combine them
* Hide the noun form - always lead with what the thing IS

**Examples from Actual Domain Analysis:**

DON'T - Verb-Based Concept Names (from initial mistakes):
* ❌ "Animation Resolution"
  - Violates §7: "Resolution" is a verb (resolving), not a noun
  - Creates artificial separation from "Animation"
  - Should be integrated into "Animation" concept
* ❌ "Animation Execution"
  - Violates §7: "Execution" is a verb (executing), not a noun
  - Duplicates "Animation" concept with different verb
  - Should be behavior on "Animation", not separate concept
* ❌ "Script Generation"
  - Violates §7: "Generation" is a verb (generating)
  - Should be "Script" concept with "Generates" behavior
  - Unless Generation has its own complex state/logic
* ❌ BEFORE structure:
```
Power Item
	Wrapper for power

Animation Resolution
	Finds appropriate animation
	Returns animation object
	
Animation Execution
	Plays resolved animation
	Executes when triggered
```
  - Violates §7: Split "Animation" into two verb-based concepts
  - User sees ONE thing: "Animation" that resolves and executes

DO - Noun-Based Concept Names with Behaviors (after corrections):
* ✅ "Animation"
  - Noun: the playable animation itself
  - Behaviors: "Resolves from sources", "Executes when triggered"
  - Single concept with multiple responsibilities
* ✅ "Power Item"
  - Noun: the wrapper object
  - Behaviors: "Stores characteristics", "Generates names"
* ✅ "Script"
  - Noun: the executable code
  - Behaviors: "Generates from configuration", "Runs via Function wrapper"
* ✅ AFTER structure:
```
Power Item (PowerItem class)
	Wrapper for power providing characteristics
	Stores descriptor, effect, range, area
	Generates descriptor names for animation lookup (behavior)
	
	RELATIONSHIPS:
		USED BY: Animation

Animation
	Playable animation for a power
	Resolves from multiple sources through priority system (behavior)
	Executes when triggered by game events (behavior)
	
	RELATIONSHIPS:
		USES: Power Item
		CONTAINS: Resolution priority logic
		CONTAINS: Execution logic
	
	Resolution Priority (Highest to Lowest)
		Attached Macro
			Item flag 'descriptorMacro' on power
			Executes macro directly
		
		Name-Matched Macro
			Searches game macros for name match
			Executes matched macro
```
  - Follows §7: "Animation" is noun with behaviors
  - Follows §7: Resolution and Execution integrated as behaviors
  - Clear what Animation IS, then what it DOES

DON'T - Another Example:
* ❌ BEFORE (violated §7):
```
Combat Data Extraction
	Extracts combat results from chat messages
	Parses attack data from HTML
	Identifies attacker and target
```
  - Violates §7: "Extraction" is verb-based
  - Should be "Combat Data" or "Combat Result"

* ✅ AFTER (follows §7):
```
Combat Result
	Attack outcome data from combat event
	Extracts from chat messages and hooks (behavior)
	Parses attack data from HTML content (behavior)
	Identifies attacker token and target token (behavior)
	Determines hit/miss/critical status (behavior)
```
  - Follows §7: "Combat Result" is the noun (the data)
  - Behaviors describe how it's obtained and what it contains

**When Verbs Become Nouns:**

Sometimes a verb represents enough state and logic to become its own concept:

* ✅ "Animation" (not "Animating")
  - Has state: type, name, source, play function
  - Has logic: resolution priority, execution methods
  - Noun form captures the artifact

* ✅ "Configuration" (not "Configuring")
  - Has state: selected descriptor, methods, preferences
  - Has logic: validation, persistence
  - Noun form captures the settings

* ✅ "Script" (not "Scripting")
  - Has state: code string, name, descriptor
  - Has logic: generation algorithms, execution wrapper
  - Noun form captures the executable artifact

**Test:**
Can you describe this concept without using a verb?
* "Animation is a playable visual effect" ✅ (noun)
* "Animation Resolution is finding the right animation" ❌ (verb disguised as noun)
* "Script is executable code" ✅ (noun)
* "Script Generation is creating code" ❌ (verb disguised as noun)

If you can't describe it without a verb, it's probably a behavior on another concept, not a concept itself.

---

## 8. Assign Behaviors to the Concept That Performs Them

**Principle:**
Always assign behaviors to the domain concept that actually performs them, not to the result or output. Ask "Who does this?" or "What class/object contains this logic?" to determine correct placement. The behavior belongs to the actor, not the artifact created.

**Do:**
* Place behavior under the concept that contains the logic
* Ask "Whose responsibility is this?" when placing behaviors
* Look at the code - which class has the method?
* Put creation logic with the creator, not the created
* Assign resolution logic to the resolver, not the resolved

**Don't:**
* Place behavior under the result/output concept
* Assign behavior based on what it produces
* Put logic under the artifact it creates
* Organize by data flow instead of responsibility

**Examples from Actual Domain Analysis:**

DON'T - Behaviors on Result Concepts (from initial mistakes):
* ❌ BEFORE (violated §8):
```
Power Item
	Wrapper for power
	Stores descriptor, effect, range, area
	
	RELATIONSHIPS:
		USED BY: Animation

Animation
	Playable animation for a power
	Resolves from multiple sources through priority system (behavior)
	Executes when triggered by game events (behavior)
	
	RELATIONSHIPS:
		USES: Power Item
		CONTAINS: Resolution priority logic
	
	Resolution Priority (Highest to Lowest)
		Attached Macro
			Checks item flag 'descriptorMacro' on power
			Executes macro directly
		
		Name-Matched Macro
			Searches game macros for match
```
  - Violates §8: Resolution Priority under Animation (the result)
  - CODE REALITY: PowerItem.animation getter contains this logic
  - Violates §8: "Resolves" behavior on Animation, but PowerItem does resolving
  - User confusion: Animation doesn't resolve itself, PowerItem resolves it

DO - Behaviors on Actor Concepts (after corrections):
* ✅ AFTER (follows §8):
```
Power Item (PowerItem class)
	Wrapper for power providing characteristics
	Stores descriptor, effect, range, area
	Generates descriptor names for animation lookup (behavior)
	Resolves Animation from multiple sources through priority system (behavior)
	
	RELATIONSHIPS:
		CREATES: Animation
	
	Animation Resolution Priority (Highest to Lowest)
		Attached Macro
			Checks item flag 'descriptorMacro' on power
			Returns Animation that executes macro directly
		
		Name-Matched Macro
			Searches game macros for expandedDescriptorName match
			Returns Animation that executes matched macro

Animation
	Playable animation for a power
	Returned by Power Item animation resolution
	Executes when triggered by game events (behavior)
	
	RELATIONSHIPS:
		CREATED BY: Power Item
		TRIGGERED BY: Game hooks
	
	Properties
		Name, Type, Play function
```
  - Follows §8: Resolution Priority under Power Item (the actor)
  - CODE REALITY: Matches PowerItem.animation getter
  - Follows §8: "Resolves" behavior on Power Item (who does it)
  - Clear responsibility: Power Item creates Animation

DON'T - Another Example:
* ❌ BEFORE (violated §8):
```
Combat Result
	Attack outcome data
	
Combat Data Extraction
	Extracts combat results from chat messages (behavior)
	Parses attack data from HTML content (behavior)
	Creates Combat Result
```
  - Violates §8: Extraction logic separated from Combat Result
  - If extraction creates Combat Result, who extracts?
  - CODE: Might be in Combat Result constructor or factory

* ✅ AFTER (follows §8):
```
Combat Result
	Attack outcome data from combat event
	Extracts from chat messages and hooks (behavior)
	Parses attack data from HTML content (behavior)
	Identifies attacker and target tokens (behavior)
	Determines hit/miss/critical status (behavior)
	
	RELATIONSHIPS:
		EXTRACTED FROM: Chat messages
		CREATED BY: Attack roll hooks
```
  - Follows §8: Extraction behaviors on Combat Result (it extracts itself)
  - CODE REALITY: Combat Result contains parsing logic
  - Clear: Combat Result knows how to extract its own data

DON'T - Another Example:
* ❌ BEFORE (violated §8):
```
Descriptor Sequence
	Complete animation sequence
	
Script Generation (SequencerScript class)
	Creates executable code from configuration (behavior)
	Generates name from descriptor, range, area (behavior)
	Applies range-based logic (behavior)
```
  - Violates §8: Generation behaviors separated from Script
  - CODE REALITY: SequencerScript.generate() method does this
  - Violates §8: Who generates? Script or Descriptor Sequence?

* ✅ AFTER (follows §8):
```
Descriptor Sequence (DescriptorSequence class)
	Complete animation sequence for power
	Composes all animation phases
	
	RELATIONSHIPS:
		USES: Sequencer Script

Sequencer Script (SequencerScript class)
	Executable code for animation
	Generates from Descriptor Sequence configuration (behavior)
	Creates JavaScript code string (behavior)
	Applies range-based logic (behavior)
	Executes via Function wrapper (behavior)
	
	RELATIONSHIPS:
		USED BY: Descriptor Sequence
```
  - Follows §8: Generation behaviors on Sequencer Script (who does it)
  - CODE REALITY: SequencerScript has generate() and run() methods
  - Clear: Script generates itself from configuration

**Code Reality Check:**

When in doubt, look at the actual code:

```javascript
class PowerItem {
    get animation() {  // ← PowerItem has animation getter
        // Resolution priority logic HERE
        if (macroId) { ... }      // Attached macro
        if (macro) { ... }         // Name-matched macro  
        if (autoRec) { ... }       // AutoRec entry
        return new Animation(...); // Returns Animation
    }
}
```
→ Resolution Priority belongs under **Power Item** (it contains the logic)

```javascript
class SequencerScript {
    generate() {  // ← SequencerScript has generate method
        // Generation logic HERE
        let script = "...";
        return script;
    }
    
    run() {  // ← SequencerScript has run method
        // Execution logic HERE
        new Function(this.script)();
    }
}
```
→ Generation and Execution belong under **Sequencer Script** (it contains the logic)

**Test:**
Which class/object has the method that does this behavior?
* PowerItem.animation getter does resolution → behavior on **Power Item** ✅
* Animation object has play() method → execution behavior on **Animation** ✅
* SequencerScript.generate() creates code → generation behavior on **Sequencer Script** ✅

If the behavior isn't in that class, it's probably in the wrong place in your domain map.

---

## 9. Avoid Noun Redundancy in Domain and Concept Names

**Principle:**
When multiple domains or concepts share the same root noun, they create ambiguity and suggest poor separation of concerns. **PREFER INTEGRATION** - nest related concepts under one domain. Only use distinct nouns when domains truly serve different purposes that cannot be integrated.

**CRITICAL: Integration is the Default Fix**
When you find multiple domains sharing a root noun:
1. **First, ask: "Can these be integrated?"** - 90% of the time, YES
2. **Only rename if truly distinct** - they serve fundamentally different purposes
3. **Default to nesting** - put variations/triggers under parent domain

**Do:**
* **INTEGRATE first**: nest "Movement Triggering" UNDER "Power Animation" (same functional area)
* **Only then rename**: use distinct nouns ONLY when integration doesn't make sense
* Test for uniqueness: can you remove the qualifier and still know what it is?
* Use subject-area nouns when domains are genuinely separate: "Combat Feedback" vs "Power Animation"

**Don't:**
* ❌ **Rename without considering integration** - this is a cop-out that hides the real issue
* ❌ Repeat same noun with different prefixes: "X Animation", "Y Animation", "Z Animation"
* ❌ Use vague qualifiers to avoid integration: "Animation 1", "Animation System", "Animation Module"
* ❌ Create parallel domains that should be nested: "POWER ANIMATION" + "MOVEMENT ANIMATION"
* ❌ Allow concept name collisions: "Animation" concept with "Sequence Runner" and "Sequencer Script"

**Examples from Actual Domain Analysis:**

DON'T - Noun Redundancy (from initial mistakes):
* ❌ BEFORE (violated § 9):
```
POWER ACTIVATION ANIMATION
	Power Item
	Animation
	Descriptor Sequence

MOVEMENT ANIMATION
	Movement Detection
	Movement Type Detection

ANIMATION CUSTOMIZATION
	Sequence Runner Editor
	Sequencer Script
```
  - Violates § 9: Three domains use "ANIMATION" as key noun
  - Violates § 9: "Sequence Runner" and "Sequencer Script" both use "Sequence" root
  - Ambiguity: Which "Animation" domain handles what?
  - Poor separation: Movement is really about triggering animations, not a separate type

DO - Integration First, Then Distinct Nouns (after corrections):
* ✅ AFTER - **INTEGRATED approach** (follows § 9):
```
POWER ACTIVATION ANIMATION
	Animated visual effects when powers are used
	
	Power Item
	Animation Resolver
	Descriptor Sequence
	
	Movement-Triggered Animation
		Detects movement and triggers animation for movement powers
		(INTEGRATED under Power Animation - same functional domain)
		
		Movement Detector
		Movement Type Detector
		Movement Power Resolver
	
	Animation Customization
		User interface for configuring animations
		(INTEGRATED under Power Animation - configuration of same domain)
		
		Sequence Runner Editor
		Sequencer Script
		Saving Custom Animations
```
  - ✅ Follows § 9: **Movement INTEGRATED** (trigger mechanism, not separate domain)
  - ✅ Follows § 9: **Customization INTEGRATED** (configuration of animations, not separate domain)
  - ✅ Single domain with clear sub-capabilities
  - ✅ All animation-related concepts together
  
**Why Integration Works:**
- Movement detection exists ONLY to trigger power animations
- Customization exists ONLY to configure power animations  
- User sees one capability: "animating powers"
- Code organization follows functional cohesion

DON'T - Another Example:
* ❌ BEFORE (violated § 9):
```
USER MANAGEMENT
	User creation
	User validation

USER AUTHENTICATION
	User login
	User sessions
```
  - Violates § 9: Both domains use "USER" as key noun
  - Should be: "IDENTITY MANAGEMENT" containing both Registration and Authentication

* ✅ AFTER (follows § 9):
```
IDENTITY MANAGEMENT
	User identity lifecycle
	
	Registration
		User creation
		Profile validation
	
	Authentication
		User login
		Session management
```
  - Follows § 9: Single domain with distinct sub-concepts
  - Clear hierarchy: Identity → Registration + Authentication

**Test for Redundancy:**

List all domain names and extract key nouns:
```
"POWER ACTIVATION ANIMATION" → Animation
"MOVEMENT ANIMATION" → Animation  
"ANIMATION CUSTOMIZATION" → Animation
```
→ VIOLATION: Same noun appears 3 times at domain level

List all concept names at same level:
```
"Sequence Runner Editor"
"Sequencer Script"
```
→ VIOLATION: "Sequence" appears in both (potential collision)

**When Repetition is OK:**

Nested concepts can share parent's noun:
```
POWER ANIMATION
	Animation (the artifact)
	Animation Resolution (finding animations)
```
✅ OK: Both under same parent, clearly related

Property values can repeat:
```
Power Item
	Stores descriptor (fire, ice, electricity...)
	Stores effect type (damage, affliction, healing...)
```
✅ OK: Data values, not concept names

**Auto-Detection:**

Automatic validation can detect:
- Multiple domains with same root noun (HIGH confidence violation)
- Multiple concepts with same root noun at same hierarchy level (MEDIUM confidence)
- **Suggest INTEGRATION first, renaming only as fallback**

**Fix Priority for § 9 Violations:**
1. **INTEGRATE** - Nest related domains under parent (90% of cases)
2. **RENAME** - Use distinct nouns only when integration impossible (10% of cases)

Examples:
- "POWER ANIMATION" + "MOVEMENT ANIMATION" → ❌ Don't rename, ✅ Integrate movement under power
- "USER MANAGEMENT" + "USER AUTHENTICATION" → ❌ Don't rename, ✅ Integrate under "IDENTITY MANAGEMENT"
- "POWER ANIMATION" + "COMBAT FEEDBACK" → ✅ Keep separate (truly distinct functional areas)

---

## Domain Structure Output Format

**Input Sources:**
- Code files (JavaScript, Python, TypeScript, etc.)
- Text documents (markdown, plain text)
- Domain maps or diagrams
- Documentation or specifications
- Any blob of text describing a system

**Output Format:**
Text-based hierarchical domain map (NOT JSON for now)

**Structure:**
```
FUNCTIONAL PURPOSE: <what this accomplishes for users>

DOMAIN NAME 1
	<what this domain accomplishes functionally>
	
	RELATIONSHIPS:
		USES: Infrastructure Component Y
	
	Foundation Concept A
		<what this concept does>
		<properties it stores>
		<operations it performs>
		
		RELATIONSHIPS:
			USES: Foundation Concept B
			CONTAINS: Nested Concept C
			TRIGGERS: Domain 2 Concept X
		
		Nested Concept C
			<nested concept integrated here>
			<operates on parent concept>
	
	Foundation Concept B
		<another foundation concept>
		<comes before concepts that use it>

DOMAIN NAME 2
	<another functional domain>
	
	Concept X
		<concept description>
		
		RELATIONSHIPS:
			TRIGGERED BY: Domain 1 Concept A
			USES: Infrastructure Component Y

SYSTEM INFRASTRUCTURE
	<technical systems enabling all domains>
	
	RELATIONSHIPS:
		SERVES: Domain 1, Domain 2
	
	Infrastructure Component Y
		<what it provides>
		
		RELATIONSHIPS:
			SERVES: Domain 1, Domain 2
			USED BY: Multiple concepts
```

**Key Principles Applied:**
1. Functional purpose at top
2. Domains ordered before infrastructure
3. Concepts ordered by user mental model (foundation → features)
4. Relationships embedded IN each concept
5. Related concepts nested/integrated
6. Outcome verbs throughout

**Validation Checklist:**
- [ ] Functional purpose stated at top
- [ ] All verbs are outcome-focused, not communication verbs (§1)
- [ ] System support integrated under domain concepts (§2)
- [ ] Concepts ordered by user mental model (foundation → features) (§3)
- [ ] Domain concepts before system infrastructure (§4)
- [ ] Functional purpose focused on accomplishment (§5)
- [ ] Related concepts maximally integrated (§6)
- [ ] Domain concepts are nouns, behaviors are verbs (§7)
- [ ] Behaviors assigned to the concept that performs them (§8)
- [ ] No noun redundancy in domain or concept names (§9)
- [ ] Relationships embedded in each concept (not separate section)

---

**See Also:**
* `\ddd-analyze` — Extract domain structure from text/code
* `\ddd-validate` — Validate existing domain structure
