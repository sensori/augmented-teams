{
  "1_shape": {
    "assumptions_made": {
      "focus_user_flow": "Focus on user flow over internal systems",
      "cover_end_to_end": "Cover the end-to-end scenario",
      "prioritize_customer_facing": "Prioritize customer-facing features",
      "independent_testable": "Assume stories should be independently testable",
      "user_value": "Assume each story delivers user value",
      "technical_infrastructure_implicit": "Assume technical infrastructure stories are implicit",
      "drill_down_architectural_uncertainty": "Drill down where architectural uncertainty is high – unknown integration patterns, new technology, or unclear system boundaries require deeper exploration",
      "drill_down_business_complexity": "Drill down where business complexity is significant – complex business rules, regulatory requirements, or domain logic that needs clarification",
      "drill_down_uniqueness": "Drill down where uniqueness creates risk – novel approaches, first-of-kind features, or untested patterns benefit from detailed shaping",
      "drill_down_integration_complexity": "Drill down where integration complexity exists – multiple systems, data dependencies, or coordination challenges need detailed mapping",
      "drill_down_user_behavior_variability": "Drill down where user behavior is highly variable – diverse user needs, multiple personas, or inconsistent workflows require deeper understanding",
      "skip_established_patterns": "Skip deep drill-down where patterns are well-established – standard CRUD operations, familiar workflows, or proven integration patterns can stay high-level",
      "focus_core_domain": "Focus on core domain over supporting domains",
      "identify_concepts_first": "Identify overall domain concepts and relationships before detailed modeling",
      "ubiquitous_language": "Use ubiquitous language from domain sources",
      "model_domain_not_technical": "Model domain concepts, not technical implementation",
      "separate_domain_infrastructure": "Separate domain logic from infrastructure concerns, where they are mentioned"
    },
    "decisions_made": {
      "drill_down_approach": [
        "Dig deep on system interactions",
        "Dig deep on user workflows"
      ],
      "depth_of_shaping": [
        "Decompose -> Discover all stories listed",
        "Testable -> Specify minimal examples"
      ],
      "flow_scope_and_granularity": "End-to-end user-system behavior – One user interaction followed by one system response",
      "bounded_context_identification": "By business capability - group by what the business does",
      "drill_down_limits": [
        "Approximate story limit: 5-10 stories"
      ],
      "structure_exploration_depth": "Behavioral -> Explore Business and Domain AC"
    }
  },
  "2_prioritization": {
    "assumptions_made": {
      "thin_slices_value_learning_risk": "Thin slices should provide either value, learning, or risk reduction",
      "slices_not_all_functionality": "Slices do not need to include all functionality to be useful",
      "not_every_increment_user_visible": "Not every increment must be user-visible if it validates key assumptions",
      "architectural_slices_unlock_features": "Some slices may be architectural if they unlock multiple features"
    },
    "decisions_made": {
      "increment_slicing_strategy": [
        "Delivering End-to-End Journey — supports integrated validation across systems and users",
        "Validating Impact - Feasibility — reduces uncertainty and derisks critical components early",
        "Maximizing Earned Value — delivers early impact and builds stakeholder confidence",
        "Increasing Reuse/Dependency— prevents downstream rework and enables reuse"
      ]
    },
    "prioritization_context": {
      "highest_risk_areas": [
        "Create Mob - foundational; if this fails, nothing else works",
        "Foundry VTT integration - external dependency risk (actor/token system)",
        "Strategy selection and target evaluation - complexity risk (combat state, multiple strategies)",
        "Range constraints - integration risk (Foundry movement/range system)"
      ],
      "highest_value_early_delivery": [
        "Create Mob + basic Execute Mob Action - delivers core value proposition (control multiple minions together, eliminates repetitive clicking)"
      ],
      "most_complex_relative_to_value": [
        "Strategy selection and target evaluation - requires Foundry combat state analysis",
        "Range constraints - requires Foundry movement system integration",
        "Template spawning - requires Foundry template system integration"
      ],
      "thin_slices_end_to_end": true,
      "reusable_components": [
        "Mob grouping logic - used by Create, Edit, and Spawn",
        "Foundry VTT integration layer - used by all features (CRITICAL)",
        "Strategy evaluation engine - used by Choose Target and Execute Action",
        "Range/positioning service - used by Execute Action"
      ],
      "project_constraints": [
        "Must integrate with Foundry VTT (external dependency)",
        "Small piece of functionality"
      ],
      "user_sequencing": "Game Masters are the only user type; no user sequencing needed"
    },
    "increment_priorities": {
      "increment_1": {
        "name": "Foundation - Create Mob and Basic Actions",
        "priority": 1,
        "rationale": "Foundational capability - if this fails, nothing else works. Delivers highest value early.",
        "includes": [
          "Create Mob (foundational, highest value)",
          "Execute Mob Action (basic - move/attack without strategy)",
          "Foundry VTT integration layer (used by all features - CRITICAL)"
        ],
        "stories": [
          "Select Minion Tokens",
          "Group Minions Into Mob",
          "Assign Mob Name",
          "Select Action Type",
          "Execute Action For All Minions",
          "Respect Range Constraints"
        ]
      },
      "increment_2": {
        "name": "Strategy and Target Selection",
        "priority": 2,
        "rationale": "Adds intelligence and strategy-driven behavior",
        "includes": [
          "Select Strategy",
          "Choose Target"
        ],
        "stories": [
          "Select Mob",
          "Choose Strategy",
          "Evaluate Available Targets",
          "Apply Strategy To Select Target",
          "Confirm Target Selection"
        ]
      },
      "increment_3": {
        "name": "Mob Management Enhancements",
        "priority": 3,
        "rationale": "Enhancement features for managing existing mobs",
        "includes": [
          "Edit Mob"
        ],
        "stories": [
          "Select Mob To Edit",
          "Add Minion To Mob",
          "Remove Minion From Mob"
        ]
      },
      "increment_4": {
        "name": "Spawn Mobs",
        "priority": 4,
        "rationale": "Convenience feature for quick mob creation",
        "includes": [
          "Spawn From Template",
          "Spawn From Actors"
        ],
        "stories": [
          "Select Mob Template",
          "Spawn Mob From Template",
          "Spawn Mob From Selected Actors"
        ]
      }
    }
  },
  "discovery": {
    "assumptions_made": {
      "default_granularity": "Default granularity is one Meaningful user/system interaction per story",
      "granularity_varies": "Story granularity may vary based on technical or functional complexity",
      "coarse_grained_acceptable": "Coarse-grained stories are acceptable where functionality is easily enabled",
      "fine_grained_required": "Fine-grained slicing is required where architectural or integration uncertainty is high"
    },
    "decisions_made": {
      "story_scope_definition": "Hierarchical — Go from left to right through every step of system and user interactions, including each alternate option. Start with top-level steps and drill down completely before moving to the next step. Includes entire set of stories for this core increment, including alternate stories and optional stories.",
      "story_granularity": "System inner behavior and inner workings — needed when elaboration of new complex architecture across unknown libraries and components is useful to elaborate. Specifically for engaging with the Foundry VTT API."
    }
  },
  "7_tests": {
    "assumptions_made": {
      "tests_match_scenarios_exactly": "Tests must match story scenarios exactly - no new steps, no modified step text",
      "test_methods_match_scenario_names": "Test methods must use exact scenario names from story documents",
      "assertions_verify_scenarios": "Assertions must verify what the scenarios say they verify",
      "real_implementations_default": "Tests should use real implementations by default",
      "mock_only_when_needed": "Only mock when explicitly needed for e2e tests or for uncontrollable external dependencies",
      "ascii_only": "All test code must use ASCII-only characters (no Unicode) - Windows console compatibility",
      "call_production_directly": "Tests should call production code directly - let tests fail naturally if code doesn't exist"
    },
    "decisions_made": {
      "test_framework": "pytest with orchestrator pattern (NO feature files)",
      "test_scope_level": "System level - test full system with external systems mocked out",
      "mocking_strategy": "Mock external dependencies - mock Foundry VTT API, integrations, external systems",
      "test_file_structure": "Match story graph exactly - test files named test_<sub_epic_name>.py, classes named Test<ExactStoryName>, methods named test_<scenario_name_snake_case>",
      "test_location": "tests/ directory mirroring story structure"
    }
  },
  "8_code": {
    "assumptions_made": {
      "maintainability_readability": "Focus on maintainability and readability over performance optimizations",
      "single_responsibility": "Single Responsibility Principle - Each function/class does one thing well",
      "dependency_injection": "Dependency Injection - Dependencies passed through constructors, not created internally",
      "immutability_preferred": "Immutability preferred - Minimize mutable state where possible",
      "explicit_over_implicit": "Explicit over implicit - Make dependencies and behavior explicit",
      "testability": "Testability - Code should be easy to test in isolation",
      "language_idioms": "Respect language-specific idioms and patterns",
      "incorporate_requirements": "When generating code, incorporate requirements from stories, domain maps, and BDD tests"
    },
    "decisions_made": {
      "architecture": "Domain-Driven Design - Services, Aggregates, Context Boundaries, Entities, Value objects, Repositories, Factories, Events, Rules",
      "dependency_management": "Constructor injection - All dependencies passed through constructors",
      "error_handling": "Language-specific patterns - Use language idioms (Python exceptions)",
      "programming_paradigm": "Object-oriented programming - Classes, objects, inheritance, polymorphism, encapsulation",
      "properties_vs_methods": "Language conventions - Follow language-specific conventions (Python @property)",
      "code_organization": "Domain layer (core entities: Mob, Minion), Service layer (business logic: MobManager, TokenSelector, MobNameValidator), Integration layer (external systems: FoundryVTTClient), Persistence layer (data storage: MobRepository)",
      "target_location": "src/mob_minion/ directory structure (Python package)"
    }
  }
}
