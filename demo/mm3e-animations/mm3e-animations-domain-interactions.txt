MM3E ANIMATIONS - DOMAIN INTERACTION ANALYSIS

This document shows how domain concepts interact to fulfill key business scenarios in the superhero power animation system.

================================================================================
SCENARIO 1: POWER ACTIVATION ANIMATION
================================================================================

TRIGGER: User activates a power (attack, ability, or effect)

ACTORS:
- Power Item
- Animation Resolver
- Descriptor Sequence
- Cast Sequence, Projection Sequence, Area Sequence, Power Effect Sequence
- Sequencer Library
- Foundry VTT Integration

FLOW:

1. Power activation detected
   Foundry triggers rollPower hook
   Hook receives power data and source token

2. Power transformation
   Power transformed into PowerItem
   PowerItem extracts characteristics: descriptor, effect type, range, area shape
   PowerItem generates descriptor names for animation lookup

3. Animation resolution (priority cascade)
   Animation Resolver searches for animation using PowerItem characteristics
   
   Priority 1: Attached Macro
   - Checks if power has flagged macro reference
   - If found: Returns macro-based animation
   
   Priority 2: Name-Matched Macro
   - Searches macros by expanded descriptor pattern (descriptor-range-area-effect)
   - Falls back to simplified descriptor pattern (descriptor-range-effect)
   - If found: Returns matched animation
   
   Priority 3: AutoRec Entry
   - Queries AutoRec animation library
   - Searches by power name first, then descriptor patterns
   - If found: Returns library animation
   
   Priority 4: Generated Animation
   - Triggers Descriptor Sequence generation
   - Creates animation from PowerItem characteristics

4. Animation playback (if generated)
   Descriptor Sequence orchestrates complete animation
   Maps descriptor to theme (fire → fireEffect, ice → iceEffect, etc.)
   Composes animation phases in sequence:
   - Cast Sequence: Power gathering at caster
   - Projection Sequence: Power traveling to target (range-based)
   - Area Sequence: Area effect spreading (shape-based)
   - Power Effect Sequence: Impact at target (effect-based)
   - Affected By Power Sequence: Persistent effect on target
   
   Sequencer Script generates executable code
   Sequencer Library plays animation

BUSINESS RULES:
- Attached macros always take precedence (user customization priority)
- Name matching tries specific patterns before generic patterns
- AutoRec provides community-curated animations
- Generated animations serve as fallback (always available)
- Descriptor themes ensure visual consistency (fire always looks like fire)
- Animation phases coordinate to show complete power activation story
- Range determines projection type (melee skips projection, ranged shows travel)
- Area shape determines spread pattern (cone, line, burst geometries)

RESULT: Power activation visually animated, making power feel distinct and clear

================================================================================
SCENARIO 2: COMBAT OUTCOME FEEDBACK
================================================================================

TRIGGER: Attack roll completes with result (hit, miss, or critical)

ACTORS:
- Combat Data Extractor
- Text Animation System
- Attack Result Indicators (Hit, Miss, Critical Hit Celebration)
- Foundry VTT Integration
- JB2A Assets

FLOW:

1. Attack result detected
   Foundry triggers attackRolled hook
   Hook receives result, attacker token, target token, attack data

2. Alliance determination
   Combat Data Extractor determines player perspective
   Identifies if target is ally or enemy

3. Result interpretation
   Combat Data Extractor parses attack result
   Extracts outcome: critical hit, regular hit, or miss

4. Indicator selection
   Result type determines indicator:
   - Critical: Special celebration effect
   - Hit: Text indicator
   - Miss: Text indicator

5. Visual feedback creation
   Text Animation System creates floating text beside target
   
   Alliance perspective determines color:
   - Ally hits: Red (bad for player)
   - Enemy hits: Green (good for player)  
   - Ally misses: Green (relief for player)
   - Enemy misses: Red (bad for player)
   
   Critical hits get enhanced treatment:
   - Ally criticals: JB2A celebration effect
   - Enemy criticals: Large dramatic text

6. Animation playback
   Text animates with fade and movement effects
   Sized appropriately for message importance

BUSINESS RULES:
- Alliance perspective inverts colors (player-centric view)
- Critical hits receive special visual treatment
- Text size scales with importance (criticals larger)
- All indicators appear beside target for immediate clarity
- Animation timing coordinates with attack resolution
- Feedback appears consistently regardless of animation state

RESULT: Combat outcome immediately clear through visual feedback

================================================================================
SCENARIO 3: MOVEMENT-TRIGGERED ANIMATION
================================================================================

TRIGGER: User drags token to move it on the map

ACTORS:
- Movement Detector
- Movement Type Detector
- Movement Power Resolver
- Power Item
- Animation Resolver
- Foundry VTT Integration

FLOW:

1. Movement initiation detected
   Movement Detector hooks into Foundry token drag system
   Intercepts drag before movement executes

2. Movement type determination
   Movement Type Detector reads actor's selected movement mode
   Maps game system mode to animation type:
   - Flight, Leaping, Swimming, Burrowing, Superspeed, Teleport, Ground

3. Movement power lookup
   Movement Power Resolver searches actor's powers
   Matches movement type to power name patterns, notes, or effects
   Returns movement power if found

4. Power transformation and animation resolution
   Movement power transformed into PowerItem
   Animation Resolver performs priority cascade (same as Scenario 1)
   Resolves animation for movement power

5. Animation playback with movement coordination
   Animation plays before or during movement
   
   Special case - Teleport:
   - Animation plays
   - Drag operation cancelled
   - Character appears at destination (instant travel)
   
   Standard movement:
   - Animation plays
   - Normal movement proceeds

BUSINESS RULES:
- Movement type determined by actor's active movement mode
- Each movement type can have distinct animation
- Movement powers found by keyword matching (flight, swimming, etc.)
- Teleport cancels drag (instant travel vs continuous movement)
- Animation reuses Power Activation Animation priority cascade
- If no movement power found, no animation plays (normal movement)
- Movement detection only active when module setting enabled

RESULT: Movement visually animated based on character's movement powers

================================================================================
SCENARIO 4: CUSTOM ANIMATION CONFIGURATION
================================================================================

TRIGGER: User clicks edit button on power item sheet

ACTORS:
- Sequence Runner Editor
- Descriptor Sequence View
- Cast/Projection/Area/Effect/Affected Sequence Views
- Sequencer Script View
- Power Item
- Foundry VTT Integration

FLOW:

1. Editor launch
   Foundry triggers renderItemSheet hook
   Sequence Runner Editor opens as dialog

2. Power analysis
   Editor receives power item
   Power transformed into PowerItem for characteristics

3. Configuration interface presentation
   Descriptor Sequence View organizes editor by animation phases
   Each phase presents configuration options:
   - Cast Sequence View: Cast animation selection
   - Projection Sequence View: Projectile selection (range-aware)
   - Area Sequence View: Area effect selection (shape-aware)
   - Power Effect Sequence View: Impact selection (effect-aware)
   - Affected By Power Sequence View: Persistent effect selection

4. Source mode selection (per phase)
   User chooses animation source:
   - Descriptor: Uses power's descriptor theme
   - Macro: Searches available macros
   - AutoRec: Queries animation library
   
   Available methods update based on source mode choice

5. Animation preview
   Sequencer Script View shows generated code
   User can test animation with preview button
   Preview plays animation without saving

6. Script generation
   Sequencer Script generates executable code from configuration
   Builds JavaScript integrating all phase selections
   Applies PowerItem characteristics (range, area, effect)
   Integrates token helpers and game context

BUSINESS RULES:
- Configuration organized by animation phases (matches playback order)
- Source modes provide different animation catalogs
- Available methods filter by power characteristics (range-aware, shape-aware)
- Preview allows testing before commitment
- Generated script self-contained (can be saved as macro)
- Configuration respects power limitations (melee powers hide projection options)

RESULT: User configures custom animation matching their power concept

================================================================================
SCENARIO 5: CUSTOM ANIMATION PERSISTENCE
================================================================================

TRIGGER: User saves configured animation from Sequence Runner Editor

ACTORS:
- Saving Custom Animations
- Sequencer Script
- Animation Resolver
- Foundry VTT Integration

FLOW:

1. Save initiation
   User confirms animation configuration in editor
   Sequencer Script contains generated code

2. Storage decision
   User chooses storage method:
   - Power Flag: Embedded in power item
   - Macro: Separate game macro
   
   Power flag (preferred):
   - Macro created in game
   - Macro reference flagged on power item
   - Tight coupling between power and animation
   
   Standalone macro:
   - Macro created with descriptor-based name
   - Name-matching enables automatic discovery
   - Reusable across similar powers

3. Persistence
   Configuration stored to Foundry database
   Flag or macro permanently associated with power

4. Priority elevation
   Saved animation becomes highest priority
   
   If saved as flagged macro:
   - Animation Resolver finds in Priority 1 (attached)
   - Always plays for this power
   
   If saved as named macro:
   - Animation Resolver finds in Priority 2 (name-matched)
   - Plays if no attached macro exists

5. Subsequent activations
   When power activates (Scenario 1)
   Animation Resolver discovers saved animation in priority cascade
   Custom animation plays instead of generated fallback

BUSINESS RULES:
- Attached macros (flagged) take absolute precedence
- Named macros discovered by descriptor pattern matching
- Custom animations override AutoRec and generated animations
- Multiple powers can share named macro (reuse by pattern)
- Configuration persists across game sessions
- Users can update or remove custom animations anytime

RESULT: Custom animation permanently associated with power, plays on every activation

================================================================================
SCENARIO 6: CHAT CARD MANUAL ANIMATION TRIGGER
================================================================================

TRIGGER: User clicks "Run Animation" button on attack chat card

ACTORS:
- Combat Data Extractor
- Power Item
- Animation Resolver
- Foundry VTT Integration

FLOW:

1. Button click detected
   Foundry triggers renderChatMessage hook
   Button handler extracts chat message data

2. Attack reconstruction
   Combat Data Extractor parses chat card
   Identifies attacker, target, and attack data
   Retrieves tokens from canvas

3. Power lookup
   Attack references linked power
   Power retrieved from actor
   Power transformed into PowerItem

4. Template coordination (if area attack)
   Checks if attack has area effect
   Waits for template placement completion
   Waits for attacker token re-selection

5. Animation resolution and playback
   Animation Resolver performs priority cascade
   Animation plays using resolved source
   (Same resolution as Scenario 1)

BUSINESS RULES:
- Button only appears when module setting enabled
- Requires valid attacker and target tokens on canvas
- Area attacks coordinate with template placement system
- Animation plays regardless of when button clicked (replay capability)
- Uses same priority cascade as automatic activation
- Manual trigger useful for debugging or demonstration

RESULT: Power animation replays on demand from chat history

================================================================================
CROSS-DOMAIN INTERACTIONS
================================================================================

POWER ACTIVATION ANIMATION ↔ MOVEMENT-TRIGGERED ANIMATION:
- Movement reuses PowerItem transformation
- Movement reuses Animation Resolver priority cascade
- Movement adds specialized lookup (Movement Type Detector, Movement Power Resolver)
- Movement adds coordination rule (teleport cancels drag)

POWER ACTIVATION ANIMATION ↔ ANIMATION CUSTOMIZATION:
- Customization operates on PowerItem characteristics
- Customization generates configurations that become Priority 1/2 animations
- Customization previews use same Descriptor Sequence generation
- Saved configurations integrate into Animation Resolver cascade

ANIMATION CUSTOMIZATION → POWER ACTIVATION ANIMATION:
- Saved custom animations elevate to highest priority
- Flagged macros become Priority 1 (attached)
- Named macros become Priority 2 (name-matched)
- Future activations automatically discover custom animations

COMBAT FEEDBACK ↔ FOUNDRY VTT INTEGRATION:
- Combat hooks trigger feedback independently of animation
- Feedback works with or without power animations
- Feedback timing coordinates but doesn't depend on animation completion

ALL DOMAINS ↔ FOUNDRY VTT INTEGRATION:
- Foundry provides hooks for event detection
- Foundry provides token, actor, and item systems
- Foundry provides settings for feature enablement
- All domains respond to Foundry lifecycle events

ALL DOMAINS ↔ SEQUENCER LIBRARY:
- Sequencer provides animation effect catalog
- Sequencer provides descriptor-themed effect classes
- Sequencer executes generated animation scripts
- All visual effects route through Sequencer API

================================================================================
CONFIGURATION AND FEATURE TOGGLES
================================================================================

Module provides three feature toggles via Foundry settings:

1. Animate on Attack
   - Controls automatic power animation on activation
   - Affects Scenario 1 (Power Activation)
   - Default: Enabled

2. Show Animation Button on Chat Cards
   - Controls manual animation trigger visibility
   - Affects Scenario 6 (Chat Card Trigger)
   - Default: Enabled

3. Animate on Movement
   - Controls movement-based animation triggering
   - Affects Scenario 3 (Movement-Triggered Animation)
   - Default: Enabled

Configuration Management maintains these settings through Foundry settings API.
Event Detector checks settings before triggering scenarios.

================================================================================
END OF DOMAIN INTERACTION ANALYSIS
================================================================================

